{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[414],{955:function(r,n,t){\"use strict\";t.r(n);var a=t(12),e=Object(a.a)({},(function(){var r=this.$createElement,n=this._self._c||r;return n(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":this.$parent.slotKey}},[n(\"p\",[this._v(\"快速排序实现思路：随机取出一个值进行划分，大于该值放右边，小于该值放左边（该算法在经典快排的基础上经过荷兰国旗思想和随机思想进行了改造）\\n时间复杂度：O(N*logN)\\n空间复杂度：O(logN)\")]),this._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[this._v(\"function quickSort(arr) {\\n    if(arr == null || arr.length <= 0){\\n        return [];\\n    }\\n    quick(arr, 0, arr.length - 1);\\n}\\n\\nfunction quick(arr, L, R){\\n    //递归结束条件是L >= R\\n    if(L < R){\\n        //随机找一个值，然后和最后一个值进行交换，将经典排序变为快速排序\\n        swap(arr, L + Math.floor(Math.random() * (R - L + 1)), R);\\n        //利用荷兰国旗问题获得划分的边界，返回的值是小于区域的最大索引和大于区域的最小索引，在这利用荷兰国旗问题将等于区域部分就不用动了\\n        var tempArr = partition(arr, L, R, arr[R]);\\n        quick(arr, L, tempArr[0]);\\n        quick(arr, tempArr[1], R);\\n    }\\n}\\n//返回值是小于区域最后的索引和大于区域的第一个索引\\nfunction partition(arr, L, R, num){\\n    var less = L - 1;\\n    var more = R + 1;\\n    var cur = L;\\n    while(cur < more){\\n        if(arr[cur] < num){\\n            swap(arr, ++less, cur++);\\n        }else if(arr[cur] > num) {\\n            swap(arr, --more, cur);\\n        }else{\\n            cur++;\\n        }\\n    }\\n    return [less, more];\\n}\\nfunction swap(arr, i, j){\\n    var temp = arr[i];\\n    arr[i] = arr[j];\\n    arr[j] = temp;\\n}\\n\")])])]),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[this._v(\"\\n// 面试适用\\nvar quickSort = function(arr) {\\n  debugger\\n  if (arr.length <= 1) {\\n    return arr;\\n  }\\n  var pivotIndex = Math.floor(arr.length / 2);\\n  var pivot = arr.splice(pivotIndex, 1)[0];\\n  var left = [];\\n  var right = [];\\n\\n  for (var i = 0; i < arr.length; i++) {\\n    if (arr[i] < pivot) {\\n      left.push(arr[i]);\\n    } else {\\n      right.push(arr[i]);\\n    }\\n  }\\n  return quickSort(left).concat([pivot], quickSort(right));\\n};\\n\\n\")])])])])}),[],!1,null,null,null);n.default=e.exports}}]);","extractedComments":[]}