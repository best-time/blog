{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[126],{668:function(e,n,t){\"use strict\";t.r(n);var a=t(12),s=Object(a.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":e.$parent.slotKey}},[t(\"h1\",{attrs:{id:\"vue\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#vue\"}},[e._v(\"#\")]),e._v(\" vue\")]),e._v(\" \"),t(\"p\",[e._v(\"vue  面试问题总结\\nhttps://juejin.cn/post/6984210440276410399\")]),e._v(\" \"),t(\"h2\",{attrs:{id:\"vue实现双向绑定\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#vue实现双向绑定\"}},[e._v(\"#\")]),e._v(\" vue实现双向绑定\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"Vue 数据双向绑定主要是指：数据变化更新视图，视图变化更新数据，如下图所示：\\n\\n输入框内容变化时，Data 中的数据同步变化。即 View => Data 的变化。\\n\\nData 中的数据变化时，文本节点的内容同步变化。即 Data => View 的变化。\\n\\n其中，View 变化更新 Data ，可以通过事件监听的方式来实现，所以 Vue 的数据双向绑定的工作主要是如何根据 Data 变化更新 View。\\n\\nVue 主要通过以下 4 个步骤来实现数据双向绑定的：\\n\\n实现一个监听器 Observer：对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。\\n\\n实现一个解析器 Compile：解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。\\n\\n实现一个订阅者 Watcher：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。\\n\\n实现一个订阅器 Dep：订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。\\n\")])])]),t(\"h2\",{attrs:{id:\"响应式原理\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#响应式原理\"}},[e._v(\"#\")]),e._v(\" 响应式原理\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"\\nhttps://mp.weixin.qq.com/s/aiMEo_-n3QLHzlr2V9mTvw\\n\\n当创建Vue实例时,vue会遍历data选项的属性,利用Object.defineProperty为属性添加getter和setter对数据的读取进行劫持（getter用来依赖收集,setter用来派发更新）,并且在内部追踪依赖,在属性被访问和修改时通知变化。\\n\\n每个组件实例会有相应的watcher实例,会在组件渲染的过程中记录依赖的所有数据属性（进行依赖收集,还有computed watcher,user watcher实例）,之后依赖项被改动时,setter方法会通知依赖与此data的watcher实例重新计算（派发更新）,从而使它关联的组件重新渲染。\\n\")])])]),t(\"h2\",{attrs:{id:\"nexttick-原理\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#nexttick-原理\"}},[e._v(\"#\")]),e._v(\" nextTick 原理\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"mutationObserve: MO是HTML5中的API，是一个用于监视DOM变动的接口，它可以监听一个DOM对象上发生的子节点删除、属性修改、文本内容修改等\\nex:\\nconst observer = new MutationObserver(callback)\\n\\nconst textNode = '想要监听的Don节点'\\n\\nobserver.observe(textNode, {\\n    characterData: true // 说明监听文本内容的修改\\n})\\n\\nnextTick 源码主要分为两块：能力检测和根据能力检测以不同方式执行回调队列\\n能力检测\\n由于宏任务耗费的时间是大于微任务的，所以在浏览器支持的情况下，优先使用微任务。如果浏览器不支持微任务，再使用宏任务\\n\\n延迟调用优先级如下：\\nPromise > MutationObserver > setImmediate > setTimeout\\n\\n应用场景：\\n\\n在Vue生命周期的created()钩子函数进行的DOM操作一定要放在Vue.nextTick()的回调函数中。\\n原因：是created()钩子函数执行时DOM其实并未进行渲染。\\n\\n在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构的时候，这个操作应该放在Vue.nextTick()的回调函数中。\\n原因：Vue异步执行DOM更新，只要观察到数据变化，Vue将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变，如果同一个watcher被多次触发，只会被推入到队列中一次。\\n\")])])]),t(\"h2\",{attrs:{id:\"优化this取值\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#优化this取值\"}},[e._v(\"#\")]),e._v(\" 优化this取值\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"\\nhttps://mp.weixin.qq.com/s/d_uHH4R-lOudYMJgmLJ-LA\\n\")])])]),t(\"h2\",{attrs:{id:\"diff-算法\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#diff-算法\"}},[e._v(\"#\")]),e._v(\" diff 算法\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"\\nhttps://mp.weixin.qq.com/s/_-LJXLKWj3vgWQY7H6EnHw\\n\\n3.0 的 diff 算法\\nhttps://mp.weixin.qq.com/s/yodYjnG5u_ogL0rxI1wOLQ\\n\\n\\nmixins   vuex\\nhttps://mp.weixin.qq.com/s/jNHvJ233ieCsuJuP82C5Sw\\n\\nvue 思维导图\\nhttps://zhuanlan.zhihu.com/p/269766611\\n\\nvue 9个优化技巧  黄轶\\nhttps://mp.weixin.qq.com/s/VN9nwJJrs-SNn8phdrrKWg\\n\\n\\n\")])])]),t(\"h2\",{attrs:{id:\"vue-的单向数据流\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#vue-的单向数据流\"}},[e._v(\"#\")]),e._v(\" Vue 的单向数据流\")]),e._v(\" \"),t(\"p\",[e._v(\"所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。\\n这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。\")]),e._v(\" \"),t(\"p\",[e._v(\"额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。\\n子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。\")]),e._v(\" \"),t(\"p\",[e._v(\"有两种常见的试图改变一个 prop 的情形 : (data接收  computed)\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。 在这种情况下，最好定义一个本地的 data 属性并将这个 prop 用作其初始值：\\n\\nprops: ['initialCounter'],\\ndata: function () {\\n  return {\\n    counter: this.initialCounter\\n  }\\n}\\n这个 prop 以一种原始的值传入且需要进行转换。 在这种情况下，最好使用这个 prop 的值来定义一个计算属性\\n\\nprops: ['size'],\\ncomputed: {\\n  normalizedSize: function () {\\n    return this.size.trim().toLowerCase()\\n  }\\n}\\n\")])])]),t(\"h2\",{attrs:{id:\"computed-和-watch\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#computed-和-watch\"}},[e._v(\"#\")]),e._v(\" computed 和 watch\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"\\ncomputed： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；\\n\\nwatch： 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；\\n\\n运用场景：\\n\\n当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；\\n\\n当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。\\n\")])])]),t(\"h2\",{attrs:{id:\"父子组件生命周期执行顺序\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#父子组件生命周期执行顺序\"}},[e._v(\"#\")]),e._v(\" 父子组件生命周期执行顺序\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"\\nVue 的父组件和子组件生命周期钩子函数执行顺序？\\nVue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分：\\n\\n加载渲染过程\\n\\n父 beforeCreate -> 父 created -> 父 beforeMount ->\\n子 beforeCreate -> 子 created -> 子 beforeMount -> 子 mounted ->\\n父 mounted\\n\\n子组件更新过程\\n\\n父 beforeUpdate ->\\n子 beforeUpdate -> 子 updated ->\\n父 updated\\n\\n父组件更新过程\\n\\n父 beforeUpdate -> 父 updated\\n\\n销毁过程\\n\\n父 beforeDestroy ->\\n子 beforeDestroy -> 子 destroyed ->\\n父 destroyed\\n\")])])]),t(\"h2\",{attrs:{id:\"父组件监听子组件生命周期\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#父组件监听子组件生命周期\"}},[e._v(\"#\")]),e._v(\" 父组件监听子组件生命周期\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v('1. $emit()\\n// Parent.vue\\n<Child @mounted=\"doSomething\"/>\\n\\n// Child.vue\\nmounted() {\\n  this.$emit(\"mounted\");\\n}\\n\\n2. @hook:\\n\\n//  Parent.vue\\n<Child @hook:mounted=\"doSomething\" ></Child>\\n\\ndoSomething() {\\n   console.log(\\'父组件监听到 mounted 钩子函数 ...\\');\\n},\\n\\n//  Child.vue\\nmounted(){\\n   console.log(\\'子组件触发 mounted 钩子函数 ...\\');\\n},\\n\\n// 以上输出顺序为：\\n// 子组件触发 mounted 钩子函数 ...\\n// 父组件监听到 mounted 钩子函数 ...\\n')])])]),t(\"h2\",{attrs:{id:\"keep-alive\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#keep-alive\"}},[e._v(\"#\")]),e._v(\" keep-alive\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"\\nkeep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，其有以下特性：\\n\\n一般结合路由和动态组件一起使用，用于缓存组件；\\n\\n提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高；\\n\\n对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。\\n\\nhttps://www.jianshu.com/p/9523bb439950\\n\\n\")])])]),t(\"h2\",{attrs:{id:\"v-model-原理\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#v-model-原理\"}},[e._v(\"#\")]),e._v(\" v-model 原理\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"\\ntext 和 textarea 元素使用 value 属性和 input 事件；\\n\\ncheckbox 和 radio 使用 checked 属性和 change 事件；\\n\\nselect 字段将 value 作为 prop 并将 change 作为事件。\\n\\n如果在自定义组件中，v-model 默认会利用名为 value 的 prop 和名为 input 的事件\\n\\n\")])])]),t(\"h2\",{attrs:{id:\"vue-通信方式\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#vue-通信方式\"}},[e._v(\"#\")]),e._v(\" vue 通信方式\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v('\\n（1）props / $emit 适用 父子组件通信\\n\\n这种方法是 Vue 组件的基础，相信大部分同学耳闻能详，所以此处就不举例展开介绍。\\n\\n（2）ref 与 $parent / $children 适用 父子组件通信\\n\\nref：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例\\n\\n$parent / $children：访问父 / 子实例\\n\\n（3）EventBus （$emit / $on） 适用于 父子、隔代、兄弟组件通信\\n\\n这种方法通过一个空的 Vue 实例作为中央事件总线（事件中心），用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子、隔代、兄弟组件。\\n\\n（4）$attrs/$listeners 适用于 隔代组件通信\\n\\n$attrs：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 ( class 和 style 除外 )。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外 )，并且可以通过 v-bind=\"$attrs\" 传入内部组件。通常配合 inheritAttrs 选项一起使用。\\n\\n$listeners：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=\"$listeners\" 传入内部组件\\n\\n（5）provide / inject 适用于 隔代组件通信\\n\\n祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量。provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。\\n\\n（6）Vuex 适用于 父子、隔代、兄弟组件通信\\n\\nVuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。\\n\\nVuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。\\n\\n改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化\\n')])])]),t(\"h2\",{attrs:{id:\"vuex\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#vuex\"}},[e._v(\"#\")]),e._v(\" vuex\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"\\nVuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。\\n\\n（1）Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。\\n\\n（2）改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。\\n\\n主要包括以下几个模块：\\n\\nState：定义了应用状态的数据结构，可以在这里设置默认的初始状态。\\n\\nGetter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。\\n\\nMutation：是唯一更改 store 中状态的方法，且必须是同步函数。\\n\\nAction：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。\\n\\nModule：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中\\n\")])])]),t(\"h2\",{attrs:{id:\"vue-ssr\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#vue-ssr\"}},[e._v(\"#\")]),e._v(\" vue ssr\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v('\\nvue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记\"激活\"为客户端上完全可交互的应用程序。\\n\\n即：SSR大致的意思就是vue在客户端将标签渲染成的整个 html 片段的工作在服务端完成，服务端形成的html 片段直接返回给客户端这个过程就叫做服务端渲染。\\n\\n服务端渲染 SSR 的优缺点如下：\\n\\n（1）服务端渲染的优点：\\n\\n更好的 SEO：因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面；\\n\\n更快的内容到达时间（首屏加载更快）：SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间；\\n\\n（2) 服务端渲染的缺点：\\n\\n更多的开发条件限制：例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境；\\n\\n更多的服务器负载：在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 ( high traffic ) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。\\n\\n如果没有 SSR 开发经验的同学，可以参考本文作者的另一篇 SSR 的实践文章《Vue SSR 踩坑之旅》，里面 SSR 项目搭建以及附有项目源码。\\n')])])]),t(\"h2\",{attrs:{id:\"vue-router-几种\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#vue-router-几种\"}},[e._v(\"#\")]),e._v(\" vue-router 几种\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"\\nswitch (mode) {\\n  case 'history':\\n  this.history = new HTML5History(this, options.base)\\n  break\\n  case 'hash':\\n  this.history = new HashHistory(this, options.base, this.fallback)\\n  break\\n  case 'abstract':\\n  this.history = new AbstractHistory(this, options.base)\\n  break\\n  default:\\n  if (process.env.NODE_ENV !== 'production') {\\n    assert(false, `invalid mode: ${mode}`)\\n  }\\n}\\n\\n其中，3 种路由模式的说明如下：\\nhash: 使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器；\\nhistory : 依赖 HTML5 History API 和服务器配置。具体可以查看 HTML5 History 模式；\\nabstract : 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.\\n\\n（1）hash 模式的实现原理\\n\\n早期的前端路由的实现就是基于 location.hash 来实现的。其实现原理很简单，location.hash 的值就是 URL 中 # 后面的内容。比如下面这个网站，它的 location.hash 的值为 '#search'：\\n\\nhttps://www.word.com#search\\nhash 路由模式的实现主要是基于下面几个特性：\\n\\nURL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分不会被发送；\\n\\nhash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制hash 的切换；\\n\\n可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；或者使用 JavaScript 来对 loaction.hash 进行赋值，改变 URL 的 hash 值；\\n\\n我们可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染）。\\n\\n（2）history 模式的实现原理\\n\\nHTML5 提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：history.pushState() 和 history.repalceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示：\\n\\nwindow.history.pushState(null, null, path);\\nwindow.history.replaceState(null, null, path);\\nhistory 路由模式的实现主要基于存在下面几个特性：\\n\\npushState 和 repalceState 两个 API 来操作实现 URL 的变化 ；\\n\\n我们可以使用 popstate 事件来监听 url 的变化，从而对页面进行跳转（渲染）；\\n\\nhistory.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）。\\n\")])])]),t(\"h2\",{attrs:{id:\"vue-vm-set-实现\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#vue-vm-set-实现\"}},[e._v(\"#\")]),e._v(\" vue vm.$set() 实现\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"\\n受现代 JavaScript 的限制 ，Vue 无法检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式的。\\n\\n但是 Vue 提供了 Vue.set (object, propertyName, value) / vm.$set (object, propertyName, value) 来实现为对象添加响应式属性，那框架本身是如何实现的呢？\\n\\n我们查看对应的 Vue 源码：vue/src/core/instance/index.js\\n\\nexport function set (target: Array<any> | Object, key: any, val: any): any {\\n  // target 为数组\\n  if (Array.isArray(target) && isValidArrayIndex(key)) {\\n    // 修改数组的长度, 避免索引>数组长度导致splcie()执行有误\\n    target.length = Math.max(target.length, key)\\n    // 利用数组的splice变异方法触发响应式\\n    target.splice(key, 1, val)\\n    return val\\n  }\\n  // key 已经存在，直接修改属性值\\n  if (key in target && !(key in Object.prototype)) {\\n    target[key] = val\\n    return val\\n  }\\n  const ob = (target: any).__ob__\\n  // target 本身就不是响应式数据, 直接赋值\\n  if (!ob) {\\n    target[key] = val\\n    return val\\n  }\\n  // 对属性进行响应式处理\\n  defineReactive(ob.value, key, val)\\n  ob.dep.notify()\\n  return val\\n}\\n\\n我们阅读以上源码可知，vm.$set 的实现原理是：\\n\\n如果目标是数组，直接使用数组的 splice 方法触发相应式；\\n\\n如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用 defineReactive 方法进行响应式处理（ defineReactive 方法就是 Vue 在初始化对象时，给对象属性采用 Object.defineProperty 动态添加 getter 和 setter 的功能所调用的方法）\\n\\n\")])])]),t(\"h2\",{attrs:{id:\"key的作用\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#key的作用\"}},[e._v(\"#\")]),e._v(\" key的作用\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"\\nkey 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速。\\n\\nVue 的 diff 过程可以概括为：oldCh 和 newCh 各有两个头尾的变量 oldStartIndex、oldEndIndex 和 newStartIndex、newEndIndex，它们会新节点和旧节点会进行两两对比，即一共有4种比较方式：newStartIndex 和oldStartIndex 、newEndIndex 和 oldEndIndex 、newStartIndex 和 oldEndIndex 、newEndIndex 和 oldStartIndex，如果以上 4 种比较都没匹配，如果设置了key，就会用 key 再进行比较，在比较的过程中，遍历会往中间靠，一旦 StartIdx > EndIdx 表明 oldCh 和 newCh 至少有一个已经遍历完了，就会结束比较。具体有无 key 的 diff 过程，可以查看作者写的另一篇详解虚拟 DOM 的文章《深入剖析：Vue核心之虚拟DOM》\\n\\n所以 Vue 中 key 的作用是：key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速\\n\\n更准确：因为带 key 就不是就地复用了，在 sameNode 函数 a.key === b.key 对比中可以避免就地复用的情况。所以会更加准确。\\n\\n更快速：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快，源码如下：\\n\\nfunction createKeyToOldIdx (children, beginIdx, endIdx) {\\n  let i, key\\n  const map = {}\\n  for (i = beginIdx; i <= endIdx; ++i) {\\n    key = children[i].key\\n    if (isDef(key)) map[key] = i\\n  }\\n  return map\\n}\\n\\n\")])])]),t(\"h2\",{attrs:{id:\"vue-项目进行的优化\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#vue-项目进行的优化\"}},[e._v(\"#\")]),e._v(\" vue 项目进行的优化\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"\\n（1）代码层面的优化\\n\\nv-if 和 v-show 区分使用场景\\n\\ncomputed 和 watch 区分使用场景\\n\\nv-for 遍历必须为 item 添加 key，且避免同时使用 v-if\\n\\n长列表性能优化\\n\\n事件的销毁\\n\\n图片资源懒加载\\n\\n路由懒加载\\n\\n第三方插件的按需引入\\n\\n优化无限列表性能\\n\\n服务端渲染 SSR or 预渲染\\n\\n（2）Webpack 层面的优化\\n\\nWebpack 对图片进行压缩\\n\\n减少 ES6 转为 ES5 的冗余代码\\n\\n提取公共代码\\n\\n模板预编译\\n\\n提取组件的 CSS\\n\\n优化 SourceMap\\n\\n构建结果输出分析\\n\\nVue 项目的编译优化\\n\\n（3）基础的 Web 技术的优化\\n\\n开启 gzip 压缩\\n\\n浏览器缓存\\n\\nCDN 的使用\\n\\n使用 Chrome Performance 查找性能瓶颈\\n\")])])]),t(\"h2\",{attrs:{id:\"vue-3-0的了解\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#vue-3-0的了解\"}},[e._v(\"#\")]),e._v(\" vue 3.0的了解\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"Vue 3.0 正走在发布的路上，Vue 3.0 的目标是让 Vue 核心变得更小、更快、更强大，因此 Vue 3.0 增加以下这些新特性：\\n\\n（1）监测机制的改变\\n\\n3.0 将带来基于代理 Proxy 的 observer 实现，提供全语言覆盖的反应性跟踪。这消除了 Vue 2 当中基于 Object.defineProperty 的实现所存在的很多限制：\\n\\n只能监测属性，不能监测对象\\n\\n检测属性的添加和删除；\\n\\n检测数组索引和长度的变更；\\n\\n支持 Map、Set、WeakMap 和 WeakSet。\\n\\n新的 observer 还提供了以下特性：\\n\\n用于创建 observable 的公开 API。这为中小规模场景提供了简单轻量级的跨组件状态管理解决方案。\\n\\n默认采用惰性观察。在 2.x 中，不管反应式数据有多大，都会在启动时被观察到。如果你的数据集很大，这可能会在应用启动时带来明显的开销。在 3.x 中，只观察用于渲染应用程序最初可见部分的数据。\\n\\n更精确的变更通知。在 2.x 中，通过 Vue.set 强制添加新属性将导致依赖于该对象的 watcher 收到变更通知。在 3.x 中，只有依赖于特定属性的 watcher 才会收到通知。\\n\\n不可变的 observable：我们可以创建值的“不可变”版本（即使是嵌套属性），除非系统在内部暂时将其“解禁”。这个机制可用于冻结 prop 传递或 Vuex 状态树以外的变化。\\n\\n更好的调试功能：我们可以使用新的 renderTracked 和 renderTriggered 钩子精确地跟踪组件在什么时候以及为什么重新渲染。\\n\\n（2）模板\\n\\n模板方面没有大的变更，只改了作用域插槽，2.x 的机制导致作用域插槽变了，父组件会重新渲染，而 3.0 把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。\\n\\n同时，对于 render 函数的方面，vue3.0 也会进行一系列更改来方便习惯直接使用 api 来生成 vdom 。\\n\\n（3）对象式的组件声明方式\\n\\nvue2.x 中的组件是通过声明的方式传入一系列 option，和 TypeScript 的结合需要通过一些装饰器的方式来做，虽然能实现功能，但是比较麻烦。\\n\\n3.0 修改了组件的声明方式，改成了类式的写法，这样使得和 TypeScript 的结合变得很容易。\\n\\n此外，vue 的源码也改用了 TypeScript 来写。其实当代码的功能复杂之后，必须有一个静态类型系统来做一些辅助管理。\\n\\n现在 vue3.0 也全面改用 TypeScript 来重写了，更是使得对外暴露的 api 更容易结合 TypeScript。静态类型系统对于复杂代码的维护确实很有必要。\\n\\n（4）其它方面的更改\\n\\nvue3.0 的改变是全面的，上面只涉及到主要的 3 个方面，还有一些其他的更改：\\n\\n支持自定义渲染器，从而使得 weex 可以通过自定义渲染器的方式来扩展，而不是直接 fork 源码来改的方式。\\n\\n支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。\\n\\n基于 treeshaking 优化，提供了更多的内置功能。\\n\")])])]),t(\"h2\",{attrs:{id:\"set-如何实现响应式\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#set-如何实现响应式\"}},[e._v(\"#\")]),e._v(\" $set 如何实现响应式\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"export function set(target, key, val) {\\n  // 数组\\n  if(Array.isArray(target) && isValidArrayIndex(key)) {\\n    // 修改数组长度，避免索引大于数组长度导致splice错误\\n    target.length = Math.max(target.length, key)\\n    // 利用数组splice触发响应\\n    target.splice(key, 1, val)\\n    return val\\n  }\\n  // key 已经存在，直接修改属性值\\n  if(key in target && !(key in Object.prototype)) {\\n    target[key] = val\\n    return val\\n  }\\n  const ob = target.__ob__\\n  // target 不是响应式数据，直接赋值\\n  if(!ob) {\\n    target[key] = val\\n    return val\\n  }\\n  // 响应式处理属性\\n  defineReactive(obj.value, key, val)\\n  // 派发更新\\n  ob.dep.notify()\\n  return val\\n}\\n\\n实现原理：\\n\\n若是数组，直接使用数组的 splice 方法触发响应式。\\n若是对象，判断属性是否存在，对象是否是响应式。\\n以上都不满足，最后通过 defineReactive 对属性进行响应式处理。\\n\")])])]),t(\"h2\",{attrs:{id:\"vue-面试题\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#vue-面试题\"}},[e._v(\"#\")]),e._v(\" vue 面试题\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"https://juejin.cn/post/7023197006998978597?utm_source=gold_browser_extension\\nhttps://juejin.cn/post/7023197006998978597?utm_source=gold_browser_extension\\n\\n\")])])]),t(\"h2\",{attrs:{id:\"vue-中的-key-的作用\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#vue-中的-key-的作用\"}},[e._v(\"#\")]),e._v(\" Vue 中的 key 的作用\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"key 是 Vue 中 vnode 的唯一标记，我们的 diff 的算法中 sameVnode 和 updateChildren 中就使用到了 key。\\nsameVnode 用来判断是否为同一节点，常见的业务场景是一个列表，若 key 值是列表索引，在新增或删除的情况下会存在就地复用的问题。（简单说，复用了上一个在当前位置元素的状态）所以 key 值的唯一，确保 diff 更准确。\\nupdateChildren 中当其中四种假设都未匹配，就需要依赖老节点的 key 和 索引创建关系映射表，再用新节点的 key 去关系映射表去寻找索引进行更新，这保证 diff 算法更加快速。\\n\\n\")])])]),t(\"h2\",{attrs:{id:\"keep-alive-实现\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#keep-alive-实现\"}},[e._v(\"#\")]),e._v(\" keep-alive 实现\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"/**\\n* 遍历 cache 将不需要的缓存的从 cache 中清除\\n*/\\nfunction pruneCache (keepAliveInstance, filter) {\\n  const { cache, keys, _vnode } = keepAliveInstance\\n  for (const key in cache) {\\n    const cachedNode = cache[key]\\n    if (cachedNode) {\\n      const name = getComponentName(cachedNode.componentOptions)\\n      if (name && !filter(name)) {\\n        pruneCacheEntry(cache, key, keys, _vnode)\\n      }\\n    }\\n  }\\n}\\n/**\\n* 删除 cache 中键值为 key 的虚拟DOM\\n*/\\nfunction pruneCacheEntry (cache, key, keys, current) {\\n  const entry = cache[key]\\n  if (entry && (!current || entry.tag !== current.tag)) {\\n    // 执行组件的 destroy 钩子\\n    entry.componentInstance.$destroy()\\n  }\\n  // cache 中组件对应的虚拟DOM置null\\n  cache[key] = null\\n  // 删除缓存虚拟DOM的 key\\n  remove(keys, key)\\n}\\n\\nexport default {\\n  name: 'keep-alive',\\n  abstract: true,\\n\\n  props: {\\n    include: patternTypes,\\n    exclude: patternTypes,\\n    max: [String, Number]\\n  },\\n\\n  created () {\\n    // 缓存虚拟 DOM\\n    this.cache = Object.create(null)\\n    // 缓存虚拟DOM的键集合\\n    this.keys = []\\n  },\\n\\n  destroyed () {\\n    // 删除所有的缓存内容\\n    for (const key in this.cache) {\\n      pruneCacheEntry(this.cache, key, this.keys)\\n    }\\n  },\\n\\n  mounted () {\\n    // 监听 include、exclude 参数变化，调用 pruneCache修改缓存中的缓存数据\\n    this.$watch('include', val => {\\n      pruneCache(this, name => matches(val, name))\\n    })\\n    this.$watch('exclude', val => {\\n      pruneCache(this, name => !matches(val, name))\\n    })\\n  },\\n\\n  // 由 render 函数决定渲染结果\\n  render () {\\n    const slot = this.$slots.default\\n    // 获取第一个子组件虚拟DOM\\n    const vnode: VNode = getFirstComponentChild(slot)\\n    // 获取虚拟 DOM 的配置参数\\n    const componentOptions: ? VNodeComponentOptions = vnode && vnode.componentOptions\\n    if (componentOptions) {\\n      // 获取组件名称\\n      const name: ?string = getComponentName(componentOptions)\\n      const { include, exclude } = this\\n      // 若不在include或者在exclude中，直接退出，不走缓存机制\\n      if (\\n        (include && (!name || !matches(include, name))) ||\\n        (exclude && name && matches(exclude, name))\\n      ) {\\n        return vnode\\n      }\\n\\n      const { cache, keys } = this\\n      // 获取组件key\\n      const key: ?string = vnode.key == null\\n        ? componentOptions.Ctor.cid + (componentOptions.tag ? `::${componentOptions.tag}` : '')\\n        : vnode.key\\n      // 命中缓存\\n      if (cache[key]) {\\n        // 从 cache 中获取缓存的实例设置到当前的组件上\\n        vnode.componentInstance = cache[key].componentInstance\\n        // 删除原有存在的key，并置于最后\\n        remove(keys, key)\\n        keys.push(key)\\n      // 未命中缓存\\n      } else {\\n        // 缓存当前虚拟节点\\n        cache[key] = vnode\\n        // 添加当前组件key\\n        keys.push(key)\\n        // 若缓存组件超过max值，LRU置换\\n        if(this.max && keys.length > parseInt(this.max)) {\\n          pruneCacheEntry(cache, keys[0], keys, this._vnode)\\n        }\\n      }\\n      // 设置当前组件 keep-alive 为 true\\n      vnode.data.keepAlive = true\\n    }\\n    return vnode || (slot && slot[0])\\n  }\\n}\\n\\n\")])])]),t(\"h2\",{attrs:{id:\"vue-router-路由有几种模式-说说他们的区别\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#vue-router-路由有几种模式-说说他们的区别\"}},[e._v(\"#\")]),e._v(\" Vue-Router 路由有几种模式？说说他们的区别？\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"Vue-Router 有 3 种路由模式：hash、history、abstract。\\nhash 模式\\nVue-Router 默认为 hash 模式，基于浏览器的onhashchange事件，地址变化时，通过window.location.hash获取地址上的hash值；根据hash值匹配 routes 对象对应的组件内容。\\n特点\\n\\nhash值存在 URL 中，携带#，hash值改变不会重载页面。\\nhash改变会触发onhashchange事件，可被浏览器记录，从而实现浏览器的前进后退。\\nhash传参基于url，传递复杂参数会有体积限制。\\n兼容性好，支持低版本浏览器和 IE 浏览器。\\n\\n实现原理\\n<div class=\\\"main\\\">\\n  <a href=\\\"#/home\\\">home页面</a>\\n  <a href=\\\"#/detail\\\">detail页面</a>\\n  <div id=\\\"content\\\"></div>\\n</div>\\n<script>\\nconst routers = [{\\n  path: '/home',\\n  component: `<div>我是Home页面</div>`\\n}, {\\n  path: '/detail',\\n  component: `<div>我是Detail页面</div>`\\n}]\\n\\nfunction Router(routers) {\\n  this.routers = {}\\n  // 初始化生成 routers\\n  routers.forEach((router) => {\\n    this.routers[router] = () => {\\n      document.getElementById(\\\"content\\\").innerHTML = item.compontent;\\n    }\\n  })\\n  this.updateView = function(e) {\\n    let hash = window.location.hash.slice(1) || '/'\\n    this.routers[hash] && this.routers[hash]()\\n  }\\n  // 路由加载触发视图更新\\n  window.addEventListener('load', this.updateView.bind(this))\\n  // 路由改变触发视图更新\\n  window.addEventListener('hashchange', this.updateView.bind(this))\\n}\\n<\\/script>\\n复制代码\\nhistory 模式\\n基于HTML5新增的 pushState 和 replaceState 实现在不刷新的情况下，操作浏览器的历史纪录。前者是新增历史记录，后者是直接替换历史记录。\\n特点\\n\\nURL 不携带#，利用 pushState 和 replaceState 完成 URL 跳转而无须重新加载页面。\\nURL 更改会触发 http 请求。所以在服务端需增加一个覆盖所有情况的候选资源：若URL匹配不到任何静态资源，则应该返回同一个index.html。这个页面就是app依赖的页面。\\n\\n// nginx 服务端配置\\nlocation / {\\n  try_files $uri $uri/ /index.html;\\n}\\n复制代码\\n\\n兼容性 IE10+\\n\\n实现原理\\n<div class=\\\"main\\\">\\n  <a href=\\\"javascript:;\\\" path=\\\"/home\\\">home页面</a>\\n  <a href=\\\"javascript:;\\\" path=\\\"/detail\\\">detail页面</a>\\n  <div id=\\\"content\\\"></div>\\n</div>\\n<script>\\nconst routers = [{\\n  path: '/home',\\n  component: `<div>我是Home页面</div>`\\n}, {\\n  path: '/detail',\\n  component: `<div>我是Detail页面</div>`\\n}]\\n\\nfunction Router(routers) {\\n  this.routers = {}\\n  // 初始化生成 routers\\n  routers.forEach((router) => {\\n    this.routers[router] = () => {\\n      document.getElementById(\\\"content\\\").innerHTML = item.compontent;\\n    }\\n  })\\n  const links = [...document.getElementsByTagName('a')]\\n  links.forEach(link => {\\n    link.addEventListener('click', () => {\\n      window.history.pushState({}, null, link.getAttribute('path'))\\n      this.updateView()\\n    })\\n  })\\n  this.updateView = function() {\\n    let url = window.location.pathname || '/'\\n    this.routers[url] && this.routers[url]()\\n  }\\n  // 路由加载触发视图更新\\n  window.addEventListener('load', this.updateView.bind(this))\\n  // 路由改变触发视图更新\\n  window.addEventListener('popstate', this.updateView.bind(this))\\n}\\n<\\/script>\\n复制代码\\nabstract 模式\\n支持所有 JS 运行模式，Vue-Router 自身会对环境做校验，如果发现没有浏览器 API，路由会自动强制进入 abstract 模式。在移动端原生环境也是使用 abstract 模式。\\n\")])])]),t(\"h2\",{attrs:{id:\"路由传参方式\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#路由传参方式\"}},[e._v(\"#\")]),e._v(\" 路由传参方式\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"1\\n// 路由配置\\n{\\n  path: '/detail/:id',\\n  name: 'Detail',\\n  component: () => import('./Detail.vue')\\n}\\n// 路由跳转\\nlet id = 1\\nthis.$router.push({ path: '/detail/${id}'})\\n// 获取参数\\nthis.$route.params.id\\n\\n\\n2\\n// 路由配置\\n{\\n  path: '/detail',\\n  name: 'Detail',\\n  component: () => import('./Detail.vue')\\n}\\n// 路由跳转\\nlet id = 1\\nthis.$router.push({ name: 'Detail', params: { id: id } })\\n// 获取参数\\nthis.$route.params.id\\n\\n\\n3\\n// 路由配置\\n{\\n  path: '/detail',\\n  name: 'Detail',\\n  component: () => import('./Detail.vue')\\n}\\n// 路由跳转\\nlet id = 1\\nthis.$router.push({ name: 'Detail', query: { id: id } })\\n// 获取参数\\nthis.$route.query.id\\n\\n\\n\")])])]),t(\"h2\",{attrs:{id:\"vuex-如何知道-state-是通过-mutation-修改还是外部修改\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#vuex-如何知道-state-是通过-mutation-修改还是外部修改\"}},[e._v(\"#\")]),e._v(\" Vuex 如何知道 State 是通过 Mutation 修改还是外部修改？\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"Vuex 中修改 state 唯一渠道是执行 commit 方法，底层通过执行 this._withCommit(fn)，且设置_committing标识符为 true，才能修改 state，修改完还需要将标识符置为 false。外部修改是无法设置标识位的，所以通过 watch 监听 state 变化，来判断修改的合法性。\\n\")])])]),t(\"h2\",{attrs:{id:\"vue2-和-vue3-对比\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#vue2-和-vue3-对比\"}},[e._v(\"#\")]),e._v(\" vue2 和 vue3 对比\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"\\nhttps://juejin.cn/post/7011372376969445413\\n\\n\")])])])])}),[],!1,null,null,null);n.default=s.exports}}]);","extractedComments":[]}