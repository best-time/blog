{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[64],{605:function(n,e,t){\"use strict\";t.r(e);var a=t(12),o=Object(a.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":n.$parent.slotKey}},[t(\"h1\",{attrs:{id:\"set-map\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#set-map\"}},[n._v(\"#\")]),n._v(\" set  map\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"Set 结构的键名就是键值\\n\\n\\nSet 结构的实例有以下属性。\\n\\nSet.prototype.constructor：构造函数，默认就是Set函数。\\nSet.prototype.size：返回Set实例的成员总数。\\nSet 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。\\n\\nSet.prototype.add(value)：添加某个值，返回 Set 结构本身。\\nSet.prototype.delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。\\nSet.prototype.has(value)：返回一个布尔值，表示该值是否为Set的成员。\\nSet.prototype.clear()：清除所有成员，没有返回值。\\n\\n\\nSet 结构的实例有四个遍历方法，可以用于遍历成员。\\n\\nSet.prototype.keys()：返回键名的遍历器\\nSet.prototype.values()：返回键值的遍历器\\nSet.prototype.entries()：返回键值对的遍历器\\nSet.prototype.forEach()：使用回调函数遍历每个成员\\n\\n\\n\\n\\nWeakSet 的成员只能是对象，而不能是其他类型的值\\nWeakSet.prototype.add(value)：向 WeakSet 实例添加一个新成员。\\nWeakSet.prototype.delete(value)：清除 WeakSet 实例的指定成员。\\nWeakSet.prototype.has(value)：返回一个布尔值，表示某个值是否在 WeakSet 实例之中。\\n\\n\")])])]),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v('\\nnew Set([1, 2, 3, 4, 4])\\nnew Set(\\'aabbcc\\')\\n\\nlet set = new Set([\\'red\\', \\'green\\', \\'blue\\']);\\n\\nfor (let item of set.keys()) {\\n  console.log(item);\\n}\\n// red\\n// green\\n// blue\\n\\nfor (let item of set.values()) {\\n  console.log(item);\\n}\\n// red\\n// green\\n// blue\\n\\nfor (let item of set.entries()) {\\n  console.log(item);\\n}\\n// [\"red\", \"red\"]\\n// [\"green\", \"green\"]\\n// [\"blue\", \"blue\"]\\n\\n\\n\\nlet set = new Set([1, 4, 9]);\\nset.forEach((value, key) => console.log(key + \\' : \\' + value))\\n\\n// 1 : 1\\n// 4 : 4\\n// 9 : 9\\n\\n')])])]),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"map\\n\\n任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构都可以当作Map构造函数的参数.\\n\\nsize\\nset(k, v)\\nget(k)\\nhas(k)\\ndelete(k)\\nclear\\n\\nMap.prototype.keys()：返回键名的遍历器。\\nMap.prototype.values()：返回键值的遍历器。\\nMap.prototype.entries()：返回所有成员的遍历器。\\nMap.prototype.forEach()：遍历 Map 的所有成员。\\n\\n\\n\\nWeakMap 的语法\\nWeakMap 与 Map 在 API 上的区别主要是两个，\\n一是没有遍历操作（即没有keys()、values()和entries()方法），\\n也没有size属性。\\n因为没有办法列出所有键名，某个键名是否存在完全不可预测，跟垃圾回收机制是否运行相关。这一刻可以取到键名，下一刻垃圾回收机制突然运行了，这个键名就没了，为了防止出现不确定性，就统一规定不能取到键名。二是无法清空，即不支持clear方法。\\n因此，WeakMap只有四个方法可用：get()、set()、has()、delete()。\\n\\n\")])])]),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"const map = new Map([\\n  ['name', '张三'],\\n  ['title', 'Author']\\n]);\\n\\nmap.size // 2\\nmap.has('name') // true\\nmap.get('name') // \\\"张三\\\"\\nmap.has('title') // true\\nmap.get('title') // \\\"Author\\\"\\n\\n\\nconst set = new Set([\\n  ['foo', 1],\\n  ['bar', 2]\\n]);\\nconst m1 = new Map(set);\\nm1.get('foo') // 1\\n\\nconst m2 = new Map([['baz', 3]]);\\nconst m3 = new Map(m2);\\nm3.get('baz') // 3\\n\\n\\n\\n\\nMap 还有一个forEach方法，与数组的forEach方法类似，也可以实现遍历。\\n\\nmap.forEach(function(value, key, map) {\\n  console.log(\\\"Key: %s, Value: %s\\\", key, value);\\n});\\nforEach方法还可以接受第二个参数，用来绑定this。\\n\\nconst reporter = {\\n  report: function(key, value) {\\n    console.log(\\\"Key: %s, Value: %s\\\", key, value);\\n  }\\n};\\n\\nmap.forEach(function(value, key, map) {\\n  this.report(key, value);\\n}, reporter);\\n\\n\\n\\nMap 转为数组\\n\\nconst myMap = new Map()\\n  .set(true, 7)\\n  .set({foo: 3}, ['abc']);\\n[...myMap]\\n\\n\\n数组 转为 Map\\nnew Map([\\n  [true, 7],\\n  [{foo: 3}, ['abc']]\\n])\\n\\nMap 转对象\\nfunction strMapToObj(strMap) {\\n  let obj = Object.create(null);\\n  for (let [k,v] of strMap) {\\n    obj[k] = v;\\n  }\\n  return obj;\\n}\\n\\nconst myMap = new Map()\\n  .set('yes', true)\\n  .set('no', false);\\nstrMapToObj(myMap)\\n// { yes: true, no: false }\\n\\n\\n对象转Map\\nlet obj = {\\\"a\\\":1, \\\"b\\\":2};\\nlet map = new Map(Object.entries(obj));\\n也可以自己实现一个转换函数。\\n\\nfunction objToStrMap(obj) {\\n  let strMap = new Map();\\n  for (let k of Object.keys(obj)) {\\n    strMap.set(k, obj[k]);\\n  }\\n  return strMap;\\n}\\n\\nobjToStrMap({yes: true, no: false})\\n// Map {\\\"yes\\\" => true, \\\"no\\\" => false}\\n\\n\\nMap 转为 JSON\\n\\nMap 转为 JSON 要区分两种情况。一种情况是，Map 的键名都是字符串，这时可以选择转为对象 JSON。\\n\\nfunction strMapToJson(strMap) {\\n  return JSON.stringify(strMapToObj(strMap));\\n}\\n\\nlet myMap = new Map().set('yes', true).set('no', false);\\nstrMapToJson(myMap)\\n// '{\\\"yes\\\":true,\\\"no\\\":false}'\\n另一种情况是，Map 的键名有非字符串，这时可以选择转为数组 JSON。\\n\\nfunction mapToArrayJson(map) {\\n  return JSON.stringify([...map]);\\n}\\n\\nlet myMap = new Map().set(true, 7).set({foo: 3}, ['abc']);\\nmapToArrayJson(myMap)\\n// '[[true,7],[{\\\"foo\\\":3},[\\\"abc\\\"]]]'\\n\\n\\nJSON 转为 Map\\n\\nJSON 转为 Map，正常情况下，所有键名都是字符串。\\n\\nfunction jsonToStrMap(jsonStr) {\\n  return objToStrMap(JSON.parse(jsonStr));\\n}\\n\\njsonToStrMap('{\\\"yes\\\": true, \\\"no\\\": false}')\\n// Map {'yes' => true, 'no' => false}\\n但是，有一种特殊情况，整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为 Map。这往往是 Map 转为数组 JSON 的逆操作。\\n\\nfunction jsonToMap(jsonStr) {\\n  return new Map(JSON.parse(jsonStr));\\n}\\n\\njsonToMap('[[true,7],[{\\\"foo\\\":3},[\\\"abc\\\"]]]')\\n// Map {true => 7, Object {foo: 3} => ['abc']}\\n\\n\")])])])])}),[],!1,null,null,null);e.default=o.exports}}]);","extractedComments":[]}