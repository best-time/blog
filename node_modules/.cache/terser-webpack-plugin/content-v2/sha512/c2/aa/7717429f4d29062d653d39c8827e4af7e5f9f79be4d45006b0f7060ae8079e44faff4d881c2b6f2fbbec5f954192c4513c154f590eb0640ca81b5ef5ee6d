{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[380],{920:function(e,n,o){\"use strict\";o.r(n);var t=o(12),r=Object(t.a)({},(function(){var e=this,n=e.$createElement,o=e._self._c||n;return o(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":e.$parent.slotKey}},[o(\"h2\",{attrs:{id:\"cookie\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#cookie\"}},[e._v(\"#\")]),e._v(\" cookie\")]),e._v(\" \"),o(\"p\",[e._v(\"定义:\\nCookie是一个保存在浏览器中的简单的文本文件，该文件与特定的Web文档关联在一起，保存了该浏览器访问这个Web文档时的信息，当浏览器再次访问这个Web文档时这些信息可供该文档使用。（HTTP是无状态的协议，即HTTP协议本身不对请求和响应之间的通信状态进行保存，为了实现期望的保存状态功能，引入了cookie技术）\")]),e._v(\" \"),o(\"p\",[e._v(\"组成:\")]),e._v(\" \"),o(\"p\",[e._v(\"NAME=VALUE\\nCookie的名称和值，其中NAME是唯一标识cookie的名称，不区分大小写；VALUE是存储在Cookie里的字符串值，该值必须经过URL编码。\")]),e._v(\" \"),o(\"p\",[e._v(\"Domain=域名\\nCookie有效的域，发送到这个域的所有请求都会包含对应的Cookie。（若不指定则默认为创建Cookie的服务器的域名）\")]),e._v(\" \"),o(\"p\",[e._v(\"Path=PATH\\n请求URL中包含这个路径才会把Cookie发送到服务器（若不指定则默认为文档所在的文件目录）\")]),e._v(\" \"),o(\"p\",[e._v(\"Expires=DATE\\nCookie的有效期，默认情况下，浏览器会话结束后会删除所有cookie。\")]),e._v(\" \"),o(\"p\",[e._v(\"Secure\\n设置后仅在HTTPS安全通信时才会发送Cookie\")]),e._v(\" \"),o(\"p\",[e._v(\"HttpOnly\\n设置后只能在服务器上读取，不能再通过JavaScript读取Cookie\")]),e._v(\" \"),o(\"p\",[e._v(\"特点:\\n每个Cookie不超过4096字节；\\n每个域中Cookie个数有限制，就拿最新版来说：IE和Edge不超过50个；Firefox不超过150个；Opera不超过180个；Safari和Chrome没有限制；\\nCookie超过单个域的上限，浏览器会删除之前设置的Cookie；\\n创建的Cookie超过最大限制，该Cookie会被静默删除；\\n可设置失效时间，没有设置则会话结束会删除Cookie；\\n每个请求均会携带Cookie，若Cookie过来会带来性能问题；\\n受同源策略限制\")]),e._v(\" \"),o(\"p\",[e._v(\"操作:\")]),e._v(\" \"),o(\"div\",{staticClass:\"language- extra-class\"},[o(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[o(\"code\",[e._v(\"class CookieUtil {\\n    // 获取Cookie中的对应属性\\n    static get(name) {\\n        const cookies = document.cookie;\\n        const cookiesArr = cookies.split(';');\\n        for (let index = 0; index < cookiesArr.length; index++) {\\n            const presentCookieArr = cookiesArr[index].split('=');\\n            if (presentCookieArr[0] === name) {\\n                return presentCookieArr[1];\\n            }\\n        }\\n\\n        return null;\\n    }\\n\\n    // 设置对应的Cookie值\\n    static set(name, value, expires, path, domain, secure) {\\n        let cookieText = `${name}=${value}`;\\n        if (expires instanceof Date) {\\n            cookieText += `; expire=${expires.toGMTString()}`;\\n        }\\n        if (path) {\\n            cookieText += `; path=${path}`;\\n        }\\n        if (domain) {\\n            cookieText += `; domain=${domain}`;\\n        }\\n        if (secure) {\\n            cookieText += `; secure`;\\n        }\\n        document.cookie = cookieText;\\n    }\\n\\n    // 删除对应的Cookie\\n    static deleteCookie(name) {\\n        CookieUtil.set(name, '', new Date(0));\\n    }\\n}\\n\")])])]),o(\"h2\",{attrs:{id:\"web-storage\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#web-storage\"}},[e._v(\"#\")]),e._v(\" web Storage\")]),e._v(\" \"),o(\"p\",[e._v(\"sessionStorage\\n特点:\\nsessionStorage对象值存储会话数据，其生命周期会存储到浏览器关闭。（在该过程中刷新页面其数据不受影响）\\n浏览器在实现存储写入时使用同步阻塞方式，数据会被立即提交到存储。\\n独立打开同一个窗口同一个页面或一个Tab，sessionStorage也是不一样的。\\n存储空间大小限制为每个源不超过5M。\")]),e._v(\" \"),o(\"p\",[e._v(\"localStorage\\n生命周期是永久的，除非被清除，否则永久保存。\\n存储空间大小限制为每个源不超过5M。\\n受同源策略限制。\\n浏览器存储时采用同步存储方式。\")]),e._v(\" \"),o(\"p\",[e._v(\"localStorage.setItem(k, v)\\nlocalStorage.getItem(k)\\nlocalStorage.removeItem(k)\\nlocalStorage.clear()\\nlocalStorage.key(index)\")]),e._v(\" \"),o(\"h2\",{attrs:{id:\"indexeddb\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#indexeddb\"}},[e._v(\"#\")]),e._v(\" indexedDB\")]),e._v(\" \"),o(\"p\",[e._v(\"一个域名下可以包含多个数据库；\\n一个数据库中包含多个对象仓库，就类似于Mysql一个库中有多张表一样。\\n每个对象仓库中包含多条数据记录。\")]),e._v(\" \"),o(\"p\",[e._v(\"特点:\\nIndexedDB是浏览器中存储结构化数据的一个方案，其设计几乎是完全异步的\")]),e._v(\" \"),o(\"p\",[e._v(\"键值对存储\\n在对象仓库中，数据以“键值对”形式保存，每个数据记录都有独一无二的主键。\")]),e._v(\" \"),o(\"p\",[e._v(\"异步\\nIndexedDB操作时不会锁死浏览器，用户依然可以进行其它操作。\")]),e._v(\" \"),o(\"p\",[e._v(\"支持事务\\n一些列操作步骤之中只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。\")]),e._v(\" \"),o(\"p\",[e._v(\"受同源策略限制\\n只能访问自身域名下的数据库，不能跨域访问数据库。\")]),e._v(\" \"),o(\"p\",[e._v(\"存储空间大\\n每个源都有存储空间的限制，而且这个限制跟浏览器有关，例如Firefox限制每个源50MB，Chrome为5MB。\")]),e._v(\" \"),o(\"p\",[e._v(\"支持二进制存储\\n不仅可以存储字符串，还可以存储二进制数据（ArrayBuffer和Blob）\")]),e._v(\" \"),o(\"p\",[e._v(\"操作:\")]),e._v(\" \"),o(\"div\",{staticClass:\"language- extra-class\"},[o(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[o(\"code\",[e._v(\"class IndexedDBOperation {\\n  constructor(databaseName, version) {\\n      this.atabaseName = databaseName;\\n      this.version = version;\\n      this.request = null;\\n      this.db = null;\\n  }\\n\\n  // 数据库初始化操作\\n  init() {\\n      this.request = window.indexedDB.open(this.databaseName, this.version);\\n      return new Promise((resolve, reject) => {\\n          this.request.onsuccess = event => {\\n              this.db = event.target.result;\\n              console.log('数据库打开成功');\\n              resolve('success');\\n          };\\n          this.request.onerror = event => {\\n              console.log('数据库打开报错');\\n              reject('error');\\n          };\\n          this.request.onupgradeneeded = event =>{\\n              this.db = event.target.result;\\n              console.log('数据库升级');\\n              resolve('upgradeneeded');\\n          };\\n      });\\n  }\\n}\\n\\n\\nclass IndexedDBOperation {\\n  // ……\\n  // 创建数据仓库\\n  createObjectStore(objectStoreName, options) {\\n      let objectStore = null;\\n      if (!this.db.objectStoreNames.contains(objectStoreName)) {\\n          objectStore = this.db.createObjectStore(objectStoreName, options);\\n      }\\n      return objectStore;\\n  }\\n}\\n\\n\\n// 数据操作\\n\\nclass IndexedDBOperation {\\n  // ……\\n  // 新增内容\\n  add(objectStore, content) {\\n      objectStore.add(content);\\n  }\\n\\n  // 获取内容\\n  get(objectStore, id) {\\n      const request = objectStore.get(id);\\n      return new Promise((resolve, reject) => {\\n          request.onsuccess = resolve;\\n          request.onerror = reject;\\n      });\\n  }\\n\\n  // 更新内容\\n  update(objectStore, content) {\\n      const request = objectStore.put(content);\\n      request.onsuccess = event => {\\n          console.log('更新成功');\\n      };\\n      request.onerror = event => {\\n          console.log('更新失败');\\n      };\\n  }\\n\\n  // 删除内容\\n  remove(objectStore, deleteId) {\\n      const request = objectStore.delete(deleteId);\\n      request.onsuccess = event => {\\n          console.log('删除成功');\\n      };\\n      request.onerror = event => {\\n          console.log('删除失败');\\n      };\\n  }\\n}\\n\\n\\n// 遍历内容\\nclass IndexedDBOperation {\\n  // ……\\n  // 打印全部数据\\n  printAllDataByCursor(objectStore) {\\n      const cursorRequest = objectStore.openCursor();\\n      cursorRequest.onsuccess = event => {\\n          const cursor = event.target.result;\\n          if (cursor) {\\n              console.log(`利用游标打印的内容，id为${cursor.key}, 值为${cursor.value}`);\\n              // 移动到下一条记录\\n              cursor.continue();\\n          }\\n      };\\n  }\\n}\\n\\n\\n// 调用\\n\\nconst indexedDBOperation = new IndexedDBOperation('dbName1', 1);\\nindexedDBOperation\\n.init()\\n.then(type => {\\n    const objectStoreName = 'testObjectStore';\\n    if (type === 'upgradeneeded') {\\n        indexedDBOperation.createObjectStore(objectStoreName, {\\n            keyPath: 'id'\\n        });\\n    }\\n    const transaction = indexedDBOperation.db.transaction([objectStoreName], 'readwrite');\\n    const objectStore = transaction.objectStore(objectStoreName);\\n\\n    indexedDBOperation\\n    .get(objectStore, 1)\\n    .then(event => {\\n        if (event.target.result) {\\n            indexedDBOperation.update(objectStore, {\\n                id: 1,\\n                name: '执鸢者+纸鸢'\\n            });\\n            console.log('数据库中已经存在', event.target.result, '，则进行更新操作');\\n        }\\n        else {\\n            indexedDBOperation.add(objectStore, {\\n                id: 1,\\n                name: '执鸢者'\\n            });\\n            console.log('数据库中不存在，则进行添加');\\n        }\\n    })\\n    .catch(console.log);\\n\\n    indexedDBOperation.printAllDataByCursor(objectStore);\\n\\n    transaction.onsuccess = event => {\\n        console.log('事务操作成功');\\n    };\\n    transaction.onerror = event => {\\n        console.log('事务操作失败');\\n    };\\n    transaction.oncomplete = event => {\\n        console.log('整个事务成功完成');\\n    }\\n})\\n.catch(console.log);\\n\\n\")])])]),o(\"div\",{staticClass:\"language- extra-class\"},[o(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[o(\"code\",[e._v(\"一般来说，安全起见，cookie 都是依靠 set-cookie 头设置，且不允许 JavaScript 设置。\\nSet-Cookie: <cookie-name>=<cookie-value>\\nSet-Cookie: <cookie-name>=<cookie-value>; Expires=<date>\\nSet-Cookie: <cookie-name>=<cookie-value>; Max-Age=<non-zero-digit>\\nSet-Cookie: <cookie-name>=<cookie-value>; Domain=<domain-value>\\nSet-Cookie: <cookie-name>=<cookie-value>; Path=<path-value>\\nSet-Cookie: <cookie-name>=<cookie-value>; Secure\\nSet-Cookie: <cookie-name>=<cookie-value>; HttpOnly\\n\\nSet-Cookie: <cookie-name>=<cookie-value>; SameSite=Strict\\nSet-Cookie: <cookie-name>=<cookie-value>; SameSite=Lax\\nSet-Cookie: <cookie-name>=<cookie-value>; SameSite=None; Secure\\n\\n// Multiple attributes are also possible, for example:\\nSet-Cookie: <cookie-name>=<cookie-value>; Domain=<domain-value>; Secure; HttpOnly\\n\\n其中 <cookie-name>=<cookie-value> 这样的 kv 对，内容随你定，另外还有 HttpOnly、SameSite 等配置，一条 Set-Cookie 只配置一项 cookie\\n\\n\\n\\nExpires 设置 cookie 的过期时间（时间戳），这个时间是客户端时间。\\nMax-Age 设置 cookie 的保留时长（秒数），同时存在 Expires 和 Max-Age 的话，Max-Age 优先\\nDomain 设置生效的域名，默认就是当前域名，不包含子域名\\nPath 设置生效路径，/ 全匹配\\nSecure 设置 cookie 只在 https 下发送，防止中间人攻击\\nHttpOnly 设置禁止 JavaScript 访问 cookie，防止XSS\\nSameSite 设置跨域时不携带 cookie，防止CSRF\\n\\n\\nSecure 和 HttpOnly 是强烈建议开启的。\\nSameSite 选项需要根据实际情况讨论，因为 SameSite 可能会导致即使你用 CORS 解决了跨越问题，\\n依然会因为请求没自带 cookie 引起一系列问题，一开始还以为是 axios 配置问题，绕了一大圈，然而根本没关系。\\n\\n\\n\\n\\n\\nOAuth2.0 的流程和重点：\\n为你的应用申请 ID 和 Secret\\n准备好重定向接口\\n正确传参获取 code <- 重要\\ncode 传入你的重定向接口\\n在重定向接口中使用 code 获取 token <- 重要\\n传入 token 使用微信接口\\nOAuth2.0 着重于第三方登录和权限限制。\\n\\n\\n\")])])])])}),[],!1,null,null,null);n.default=r.exports}}]);","extractedComments":[]}