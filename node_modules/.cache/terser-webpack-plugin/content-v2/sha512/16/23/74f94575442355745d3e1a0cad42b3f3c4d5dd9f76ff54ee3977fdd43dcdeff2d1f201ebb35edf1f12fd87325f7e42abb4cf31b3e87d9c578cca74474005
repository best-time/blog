{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[402],{942:function(n,e,t){\"use strict\";t.r(e);var a=t(12),r=Object(a.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":n.$parent.slotKey}},[t(\"h4\",{attrs:{id:\"scrollbar-样式\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#scrollbar-样式\"}},[n._v(\"#\")]),n._v(\" scrollBar 样式\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"滚动条\\n\\n::-webkit-scrollbar {\\n  width: 6px;\\n  height: 6px;\\n}\\n\\n::-webkit-scrollbar-track {\\n  width: 6px;\\n  background: rgba(#101F1C, 0.1);\\n  -webkit-border-radius: 2em;\\n  -moz-border-radius: 2em;\\n  border-radius: 2em;\\n}\\n\\n::-webkit-scrollbar-thumb {\\n  background-color: rgba(#101F1C, 0.5);\\n  background-clip: padding-box;\\n  min-height: 28px;\\n  -webkit-border-radius: 2em;\\n  -moz-border-radius: 2em;\\n  border-radius: 2em;\\n}\\n\\n::-webkit-scrollbar-thumb:hover {\\n  background-color: rgba(#101F1C, 1);\\n}\\n\\ndiv::-webkit-scrollbar 滚动条整体部分\\ndiv::-webkit-scrollbar-thumb 滚动条里面的小方块，能向上向下移动（或往左往右移动，取决于是垂直滚动条还是水平滚动条\\ndiv::-webkit-scrollbar-track 滚动条的轨道（里面装有 Thumb\\ndiv::-webkit-scrollbar-button 滚动条的轨道的两端按钮，允许通过点击微调小方块的位置\\ndiv::-webkit-scrollbar-track-piece 内层轨道，滚动条中间部分（除去\\ndiv::-webkit-scrollbar-corner 边角，即两个滚动条的交汇处\\ndiv::-webkit-resizer 两个滚动条的交汇处上用于通过拖动调整元素大小的小控件注意此方案有兼容性问题，一般需要隐藏滚动条时我都是用一个色块通过定位盖上去，或者将子级元素调大，父级元素使用 overflow-hidden 截掉滚动条部分。暴力且直接。\\n\\n\")])])]),t(\"h4\",{attrs:{id:\"cookie\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#cookie\"}},[n._v(\"#\")]),n._v(\" cookie\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"cookie虽然在持久保存客户端数据提供了方便，分担了服务器存储的负担，但还是有很多局限性的。\\n第一：每个特定的域名下最多生成20个cookie\\n\\n1.IE6或更低版本最多20个cookie\\n2.IE7和之后的版本最后可以有50个cookie。\\n3.Firefox最多50个cookie\\n4.chrome和Safari没有做硬性限制\\nIE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie。\\n\\ncookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节。\\n\\nIE 提供了一种存储可以持久化用户数据，叫做userdata，从IE5.0就开始支持。每个数据最多128K，每个域名下最多1M。这个持久化数据放在缓存中，如果缓存没有清理，那么会一直存在。\\n\\n\\n优点：极高的扩展性和可用性\\n1.通过良好的编程，控制保存在cookie中的session对象的大小。\\n2.通过加密和安全传输技术（SSL），减少cookie被破解的可能性。\\n3.只在cookie中存放不敏感数据，即使被盗也不会有重大损失。\\n4.控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。\\n\\n\\n缺点：\\n1.`Cookie`数量和长度的限制。每个domain最多只能有20条cookie，每个cookie长度不能超过4KB，否则会被截掉。\\n\\n2.安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目的了。\\n\\n3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。\\n\\n//创建cookie\\nfunction setCookie(name, value, expires, path, domain, secure) {\\n    var cookieText = encodeURIComponent(name) + '=' + encodeURIComponent(value);\\n    if (expires instanceof Date) {\\n        cookieText += '; expires=' + expires;\\n    }\\n    if (path) {\\n        cookieText += '; expires=' + expires;\\n    }\\n    if (domain) {\\n        cookieText += '; domain=' + domain;\\n    }\\n    if (secure) {\\n        cookieText += '; secure';\\n    }\\n    document.cookie = cookieText;\\n}\\n\\n//获取cookie\\nfunction getCookie(name) {\\n    var cookieName = encodeURIComponent(name) + '=';\\n    var cookieStart = document.cookie.indexOf(cookieName);\\n    var cookieValue = null;\\n    if (cookieStart > -1) {\\n        var cookieEnd = document.cookie.indexOf(';', cookieStart);\\n        if (cookieEnd == -1) {\\n            cookieEnd = document.cookie.length;\\n        }\\n        cookieValue = decodeURIComponent(document.cookie.substring(cookieStart + cookieName.length, cookieEnd));\\n    }\\n    return cookieValue;\\n}\\n\\n//删除cookie\\nfunction unsetCookie(name) {\\n    document.cookie = name + \\\"= ; expires=\\\" + new Date(0);\\n}\\n\\n\")])])]),t(\"h4\",{attrs:{id:\"web-storeage\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#web-storeage\"}},[n._v(\"#\")]),n._v(\" web storeage\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。\\n\\n除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie。\\n\\n但是cookie也是不可以或缺的：cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生\\n\\n浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的userData其实就是javascript本地存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storage。\\n\\nlocalStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和removeItem等\\n\\ncookie 和session 的区别：\\n 1、cookie数据存放在客户的浏览器上，session数据放在服务器上。\\n 2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗\\n    考虑到安全应当使用session。\\n 3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能\\n     考虑到减轻服务器性能方面，应当使用COOKIE。\\n 4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。\\n 5、所以个人建议：\\n    将登陆信息等重要信息存放为SESSION\\n    其他信息如果需要保留，可以放在COOKIE中\\n\")])])]),t(\"h4\",{attrs:{id:\"html-语义化\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#html-语义化\"}},[n._v(\"#\")]),n._v(\" html 语义化\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"1，去掉或者丢失样式的时候能够让页面呈现出清晰的结构\\n2，有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；\\n3，方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；\\n4，便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。\\n\")])])]),t(\"h4\",{attrs:{id:\"doctype-作用\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#doctype-作用\"}},[n._v(\"#\")]),n._v(\" doctype 作用\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"（1）、<!DOCTYPE> 声明位于文档中的最前面，处于 <html> 标签之前。告知浏览器以何种模式来渲染文档。\\n\\n（2）、严格模式的排版和 JS 运作模式是  以该浏览器支持的最高标准运行。\\n\\n（3）、在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。\\n\\n（4）、DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现。\\n\\n该标签可声明三种 DTD 类型，分别表示严格版本、过渡版本以及基于框架的 HTML 文档。\\n HTML 4.01 规定了三种文档类型：Strict、Transitional 以及 Frameset。\\n XHTML 1.0 规定了三种 XML 文档类型：Strict、Transitional 以及 Frameset。\\nStandards （标准）模式（也就是严格呈现模式）用于呈现遵循最新标准的网页，而 Quirks\\n （包容）模式（也就是松散呈现模式或者兼容模式）用于呈现为传统浏览器而设计的网页。\\n\")])])]),t(\"h4\",{attrs:{id:\"dom-操作\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#dom-操作\"}},[n._v(\"#\")]),n._v(\" dom 操作\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"（1）创建新节点\\n\\n      createDocumentFragment()    //创建一个DOM片段\\n\\n      createElement()   //创建一个具体的元素\\n\\n      createTextNode()   //创建一个文本节点\\n\\n（2）添加、移除、替换、插入\\n\\n      appendChild()\\n\\n      removeChild()\\n\\n      replaceChild()\\n\\n      insertBefore() //在已有的子节点前插入一个新的子节点\\n\\n（3）查找\\n\\n      getElementsByTagName()    //通过标签名称\\n\\n      getElementsByName()    //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)\\n\\n      getElementById()    //通过元素Id，唯一性\\n\")])])]),t(\"h4\",{attrs:{id:\"html5有哪些新特性\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#html5有哪些新特性\"}},[n._v(\"#\")]),n._v(\" html5有哪些新特性\")]),n._v(\" \"),t(\"p\",[n._v(\"移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v('* HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。\\n\\n* 拖拽释放(Drag and drop) API\\n  语义化更好的内容标签（header,nav,footer,aside,article,section）\\n  音频、视频API(audio,video)\\n  画布(Canvas) API\\n  地理(Geolocation) API\\n  本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；\\n  sessionStorage 的数据在浏览器关闭后自动删除\\n\\n  表单控件，calendar、date、time、email、url、search\\n  新的技术webworker, websocket, Geolocation\\n\\n* 移除的元素\\n\\n纯表现的元素：basefont，big，center，font, s，strike，tt，u；\\n\\n对可用性产生负面影响的元素：frame，frameset，noframes；\\n\\n支持HTML5新标签：\\n\\n* IE8/IE7/IE6支持通过document.createElement方法产生的标签，\\n  可以利用这一特性让这些浏览器支持HTML5新标签，\\n\\n  浏览器支持新标签后，还需要添加标签默认的样式：\\n\\n* 当然最好的方式是直接使用成熟的框架、使用最多的是html5shim框架\\n   \\x3c!--[if lt IE 9]>\\n   <script> src=\"http://html5shim.googlecode.com/svn/trunk/html5.js\"<\\/script>\\n   <![endif]--\\x3e\\n如何区分：DOCTYPE声明\\\\新增的结构元素\\\\功能元素\\n')])])]),t(\"h4\",{attrs:{id:\"iframe\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#iframe\"}},[n._v(\"#\")]),n._v(\" iframe\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"1.`<iframe>`优点：\\n\\n    解决加载缓慢的第三方内容如图标和广告等的加载问题\\n    Security sandbox\\n    并行加载脚本\\n\\n2.`<iframe>`的缺点：\\n\\n\\n    *iframe会阻塞主页面的Onload事件；\\n\\n    *即时内容为空，加载也需要时间\\n    *没有语意\\n\")])])]),t(\"h4\",{attrs:{id:\"get和post的区别\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#get和post的区别\"}},[n._v(\"#\")]),n._v(\" GET和POST的区别\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符\\n    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。\\n\\n    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值，\\n    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。\\n\\n然而，在以下情况中，请使用 POST 请求：\\n无法使用缓存文件（更新服务器上的文件或数据库）\\n向服务器发送大量数据（POST 没有数据量限制）\\n发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠\\n\")])])]),t(\"h4\",{attrs:{id:\"tcp\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#tcp\"}},[n._v(\"#\")]),n._v(\" tcp\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。\\n用TCP协议把数据包送出去后，TCP不会对传送  后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了TCP的标志：SYN和ACK。\\n发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束\\n若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。\\n\")])])]),t(\"p\",[n._v(\"proxy\\nhttps://segmentfault.com/a/1190000039217566\")]),n._v(\" \"),t(\"h2\",{attrs:{id:\"微信第三方授权登录原理\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#微信第三方授权登录原理\"}},[n._v(\"#\")]),n._v(\" 微信第三方授权登录原理\")]),n._v(\" \"),t(\"p\",[n._v(\"授权流程说明\")]),n._v(\" \"),t(\"p\",[n._v(\"微信OAuth2.0授权登录让微信用户使用微信身份安全登录第三方应用或网站，在微信用户授权登录已接入微信OAuth2.0的第三方应用后，\\n第三方可以获取到用户的接口调用凭证（access_token），通过access_token可以进行微信开放平台授权关系接口调用，\\n从而可实现获取微信用户基本开放信息和帮助用户实现基础开放功能等。\")]),n._v(\" \"),t(\"p\",[n._v(\"微信OAuth2.0授权登录目前支持authorization_code模式，适用于拥有server端的应用授权。该模式整体流程为\")]),n._v(\" \"),t(\"ol\",[t(\"li\",[n._v(\"第三方发起微信授权登录请求，微信用户允许授权第三方应用后，微信会拉起应用或重定向到第三方网站，并且带上授权临时票据code参数；\")]),n._v(\" \"),t(\"li\",[n._v(\"通过code参数加上AppID和AppSecret等，通过API换取access_token；\")]),n._v(\" \"),t(\"li\",[n._v(\"通过access_token进行接口调用，获取用户基本数据资源或帮助用户实现基本操作。\")])]),n._v(\" \"),t(\"h2\",{attrs:{id:\"剪切板\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#剪切板\"}},[n._v(\"#\")]),n._v(\" 剪切板\")]),n._v(\" \"),t(\"p\",[n._v(\"bool = document.execCommand(aCommandName, aShowDefaultUI, aValueArgument)\")]),n._v(\" \"),t(\"p\",[n._v(\"Window.getSelection\\n这个方法是对用户选择的文本范围进行的一些操作。\\nconst selection = window.getSelection() ;\\nselection\\n是一个Selection对象。 如果想要将selection转换为字符串，可使用 String.toString()方法。\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\" 实现思路\\n首先要响应浏览器的copy事件，使用e.preventDefault() 阻止默认的复制事件。\\n在响应浏览器的copy事件时，通过Window.getSelection()获取到当前选中内容。然后使用document.createRange()保存下此时用户选中区的状态，以供后面使用。\\n创建一个<textarea>标签，将他移到屏幕外边，将上一步中的内容，放到文本框内。并以字符串的形式添加上额外的内容。（注：为了能在添加的内容达到换行的效果，需要使用<textarea>标签而不是<input>，需要换行处添加'\\\\n'字符串）\\n使用文本框的setSelectionRange()将文本框的内容选中，使用document.execCommand将此选中的内容进行复制。\\n最后，使用selectionObject.addRange(range)将此前选中的选区进行选中。（注：此处详见参考资料3）\\n\\n<dl id=\\\"test\\\">\\n        <dt>\\n            <code>copy</code>\\n        </dt>\\n        <dd>拷贝当前选中内容到剪贴板。启用这个功能的条件因浏览器不同而不同，而且不同时期，其启用条件也不尽相同。使用之前请检查浏览器兼容表，以确定是否可用。</dd>\\n        <dt>\\n            <code>cut</code>\\n        </dt>\\n        <dd>&nbsp;剪贴当前选中的文字并复制到剪贴板。启用这个功能的条件因浏览器不同而不同，而且不同时期，其启用条件也不尽相同。使用之前请检查浏览器兼容表，以确定是否可用。</dd>\\n        <dt>\\n            <code>paste</code>\\n        </dt>\\n        <dd>在光标位置粘贴剪贴板的内容，如果有被选中的内容，会被替换。剪贴板功能必须在 user.js 配置文件中启用。</dd>\\n    </dl>\\n\\n    <p>复制以上黑框内的内容后在下面textarea粘贴看一下</p>\\n    <textarea rows=\\\"4\\\"></textarea>\\n\\n    <script type=\\\"text/javascript\\\">\\n        function makeAdditionMessage(targetDom, additionMsg) {\\n            var body = document.getElementsByTagName('body')[0];\\n            //使用textarea可以在添加内容的时候产生换行的效果\\n            var hideTextarea = document.createElement('textarea');\\n            body.appendChild(hideTextarea);\\n            hideTextarea.style.position = 'absolute';\\n            hideTextarea.style.left = '-9999px';\\n            hideTextarea.style.top = '-9999px';\\n\\n            targetDom.addEventListener('copy', function (e) {\\n                // 禁止默认的copy事件\\n                e.preventDefault();\\n                var selectionObject = window.getSelection();\\n                var selectString = selectionObject.toString();\\n\\n                // 注意，这里制作的range光标选中框需要放在 生成新选区之前进行制作\\n                var range = document.createRange();\\n                range.setStart(selectionObject.anchorNode, selectionObject.anchorOffset);\\n                range.setEnd(selectionObject.focusNode, selectionObject.focusOffset);\\n\\n                // 添加新增的内容，并将它们放入剪切板\\n                hideTextarea.value = selectString;\\n                hideTextarea.value += additionMsg;\\n                hideTextarea.focus();\\n                hideTextarea.setSelectionRange(0, hideTextarea.value.length);\\n                var copy = document.execCommand('copy');\\n\\n                // 将此前选中的文本再进行选中\\n                selectionObject.removeAllRanges();\\n                selectionObject.addRange(range);\\n            })\\n        }\\n\\n        var test = document.getElementById('test');\\n        var msg = '\\\\n\\\\n这是额外的第一行内容\\\\n这是第二行';\\n        makeAdditionMessage(test, msg);\\n    <\\/script>\\n\")])])]),t(\"h2\",{attrs:{id:\"前端权限设计方案\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#前端权限设计方案\"}},[n._v(\"#\")]),n._v(\" 前端权限设计方案\")]),n._v(\" \"),t(\"p\",[n._v(\"https://juejin.cn/post/6949453195987025927?utm_source=gold_browser_extension\\n登录权限控制\\n页面权限控制\\n内容权限控制\")]),n._v(\" \"),t(\"p\",[n._v(\"基础权限控制\\nmeta  router + beforeEach\")]),n._v(\" \"),t(\"p\",[n._v('// 角色访问菜单权限\\nexport const permission_list = {\\nmember:[\"List\",\"Detail\"], //普通会员\\nadmin:[\"List\",\"Detail\",\"Manage\"],  // 管理员\\nsuper_admin:[\"List\",\"Detail\",\"Manage\",\"Admin\"]  // 超级管理员\\n}\\n当用户登录成功之后,通过接口返回值得知用户数据和所属角色.拿到角色值后就去配置文件里取出该角色能访问的页面列表数组,\\n随后将这部分权限数据加载到应用中从而达到权限控制的目的.\\n缺点: 修改角色权限 需要改前端代码, 最好能后台直接返回当前用户的权限列表')]),n._v(\" \"),t(\"p\",[n._v(\"vue-router 4.0 router.addRoute router.removeRoute\")]),n._v(\" \"),t(\"p\",[n._v('更细分的内容权限\\n{\\nuser_id:1,\\nuser_name:\"张三\",\\npermission_list:{\\n\"SALE\":true, //显示销售大类\\n\"S_NEED\":\"CR\", //权限编码\\n\"S_RESOURCE\":\"CURD\", //权限编码\\n}\\n}\\n指令\\napp.directive(\\'permission\\', {\\nmounted(el, binding, vnode) {\\nconst permission = binding.value; // 获取权限值\\nconst page_name = router.currentRoute.value.name; // 获取当前路由名称\\nconst have_permissions = store.state.permission_list[page_name] || \\'\\'; // 当前用户拥有的权限\\nif (!have_permissions.includes(permission)) {\\nel.parentElement.removeChild(el); //不拥有该权限移除dom元素\\n}\\n},\\n});')]),n._v(\" \"),t(\"h2\",{attrs:{id:\"webpack-实现换肤思路\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#webpack-实现换肤思路\"}},[n._v(\"#\")]),n._v(\" webpack 实现换肤思路\")]),n._v(\" \"),t(\"p\",[n._v(\"https://baijiahao.baidu.com/s?id=1648996076249510299&wfr=spider&for=pc\\nhttps://www.jianshu.com/p/35e0581629d2\")]),n._v(\" \"),t(\"h2\",{attrs:{id:\"跨域处理\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#跨域处理\"}},[n._v(\"#\")]),n._v(\" 跨域处理\")]),n._v(\" \"),t(\"p\",[n._v(\"JSONP\\nJSONP的原理是：静态资源请求不受同源策略影响。实现如下：\\nconst script = document.createElement('script')\\nscript.type = 'text/javascript'\\nscript.src = 'https://www.domain.com/a?data=1&callback=cb'\\nconst cb = res => {\\nconsole.log(JSON.stringify(res))\\n}\")]),n._v(\" \"),t(\"p\",[n._v(\"CORS\\nCORS：跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器  让运行在一个 origin (domain) 上的Web应用被准许访问来自不同源服务器上的指定的资源。\\n在各种服务端代码实现如下：\\n// 根据不同语言规则，具体语法有所不同，此处以NodeJs的express为例\\n//设置跨域访问\\napp.all('\"),t(\"em\",[n._v('\\', function(req, res, next) {\\nres.header(\"Access-Control-Allow-Origin\", \"')]),n._v('\");\\nres.header(\"Access-Control-Allow-Headers\", \"X-Requested-With\");\\nres.header(\"Access-Control-Allow-Methods\",\"PUT,POST,GET,DELETE,OPTIONS\");\\nnext();\\n});')]),n._v(\" \"),t(\"p\",[n._v(\"Nginx实现如下：\\nserver {\\n...\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",[t(\"code\",[n._v(\"add_header Access-Control-Allow-Credentials true;\\nadd_header Access-Control-Allow-Origin $http_origin;\\n\\n\\nlocation /file {\\n    if ($request_method = 'OPTIONS') {\\n        add_header Access-Control-Allow-Origin $http_origin;\\n        add_header Access-Control-Allow-Methods $http_access_control_request_method;\\n        add_header Access-Control-Allow-Credentials true;\\n        add_header Access-Control-Allow-Headers $http_access_control_request_headers;\\n        add_header Access-Control-Max-Age 1728000;\\n        return 204;\\n    }   \\n}\\n\\n...\\n\")])])]),t(\"p\",[n._v(\"}\")]),n._v(\" \"),t(\"h2\",{attrs:{id:\"tcp-udp\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#tcp-udp\"}},[n._v(\"#\")]),n._v(\" TCP UDP\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v('\\nTCP\\n传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由 IETF 的 RFC 793 定义。\\n\\n基于流的方式\\n面向连接\\n丢包重传\\n保证数据顺序\\n\\nUDP\\nInternet 协议集支持一个无连接的传输协议，该协议称为用户数据报协议（UDP，User Datagram Protocol）。UDP 为应用程序提供了一种无需建立连接就可以发送封装的 IP 数据包的方法。RFC 768 描述了 UDP。\\n\\nUDP 是非连接的协议，也就是不会跟终端建立连接\\nUDP 包信息只有 8 个字节\\nUDP 是面向报文的。既不拆分，也不合并，而是保留这些报文的边界\\nUDP 可能丢包\\nUDP 不保证数据顺序\\n\\n尹为毅的头像\\n\\n陈大鱼头 lv-4\\n2020年05月23日 阅读 29814\\n关注\\n\\n『1W7字中高级前端面试必知必会』终极版\\n作者：陈大鱼头\\ngithub： KRISACHAN\\nChrome 浏览器进程\\n在资源不足的设备上，将服务合并到浏览器进程中\\n\\n浏览器主进程\\n负责浏览器界面显示\\n\\n各个页面的管理，创建以及销毁\\n\\n将渲染进程的结果绘制到用户界面上\\n\\n网络资源管理\\n\\nGPU 进程\\n用于 3D 渲染绘制\\n网络进程\\n发起网络请求\\n插件进程\\n第三方插件处理，运行在沙箱中\\n渲染进程\\n页面渲染\\n\\n脚本执行\\n\\n事件处理\\n\\n网络传输流程\\n生成 HTTP 请求消息\\n输入网址\\n\\n浏览浏览器解析 URL\\n\\n生成 HTTP 请求信息\\n\\n\\n\\n\\n\\n收到响应\\n\\n状态码\\t含义\\n1xx\\t告知请求的处理进度和情况\\n2xx\\t成功\\n3xx\\t表示需要进一步操作\\n4xx\\t客户端错误\\n5xx\\t服务端错误\\n向 DNS 服务器查询 Web 服务器的 IP 地址\\nSocket 库提供查询 IP 地址的功能\\n\\n通过解析器向 DNS 服务器发出查询\\n\\n全世界 DNS 服务器的大接力\\n寻找相应的 DNS 服务器并获取 IP 地址\\n\\n通过缓存加快 DNS 服务器的响应\\n\\n委托协议栈发送消息\\n协议栈通过 TCP 协议收发数据的操作。\\n\\n创建套接字\\n\\n\\n浏览器，邮件等一般的应用程序收发数据时用 TCP\\nDNS 查询等收发较短的控制数据时用 UDP\\n连接服务器\\n浏览器调用 Socket.connect\\n\\n在 TCP 模块处创建表示连接控制信息的头部\\n通过 TCP 头部中的发送方和接收方端口号找到要连接的套接字\\n\\n\\n收发数据\\n浏览器调用 Socket.write\\n\\n将 HTTP 请求消息交给协议栈\\n\\n对较大的数据进行拆分，拆分的每一块数据加上 TCP 头，由 IP 模块来发送\\n\\n使用 ACK 号确认网络包已收到\\n\\n根据网络包平均往返时间调整 ACK 号等待时间\\n\\n使用窗口有效管理 ACK 号\\n\\n\\n\\nACK 与窗口的合并\\n\\n接收 HTTP 响应消息\\n\\n断开管道并删除套接字\\n浏览器调用 Socket.close\\n\\n数据发送完毕后断开连接\\n\\n\\n\\n删除套接字\\n\\n客户端发送 FIN\\n服务端返回 ACK 号\\n服务端发送 FIN\\n客户端返回 ACK 号\\n\\n\\n\\n\\n跨域\\n同源策略\\n同源策略是一个重要的安全策略，它用于限制一个origin的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。\\n\\n如果两个 URL 的 protocol 、 port (如果有指定的话)和 host 都相同的话，则这两个 URL 是同源。\\n\\n例如：\\n\\nURL\\t结果\\t原因\\nhttp://store.company.com/dir2/other.html\\t同源\\t只有路径不同\\nhttp://store.company.com/dir/inner/another.html\\t同源\\t只有路径不同\\nhttps://store.company.com/secure.html\\t失败\\t协议不同\\nhttp://store.company.com:81/dir/etc.html\\t失败\\t端口不同 ( http:// 默认端口是80)\\nhttp://news.company.com/dir/other.html\\t失败\\t主机不同\\n主要的跨域处理\\nJSONP\\n\\nJSONP的原理是：静态资源请求不受同源策略影响。实现如下：\\n\\nconst script = document.createElement(\\'script\\')\\nscript.type = \\'text/javascript\\'\\nscript.src = \\'https://www.domain.com/a?data=1&callback=cb\\'\\nconst cb = res => {\\n    console.log(JSON.stringify(res))\\n}\\n复制代码\\nCORS\\n\\nCORS：跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器 让运行在一个 origin (domain) 上的Web应用被准许访问来自不同源服务器上的指定的资源。\\n\\n在各种服务端代码实现如下：\\n\\n// 根据不同语言规则，具体语法有所不同，此处以NodeJs的express为例\\n//设置跨域访问\\napp.all(\\'*\\', function(req, res, next) {\\n    res.header(\"Access-Control-Allow-Origin\", \"*\");\\n    res.header(\"Access-Control-Allow-Headers\", \"X-Requested-With\");\\n    res.header(\"Access-Control-Allow-Methods\",\"PUT,POST,GET,DELETE,OPTIONS\");\\n    next();\\n});\\n复制代码\\nNginx实现如下：\\n\\nserver {\\n    ...\\n\\n    add_header Access-Control-Allow-Credentials true;\\n    add_header Access-Control-Allow-Origin $http_origin;\\n\\n\\n    location /file {\\n        if ($request_method = \\'OPTIONS\\') {\\n            add_header Access-Control-Allow-Origin $http_origin;\\n            add_header Access-Control-Allow-Methods $http_access_control_request_method;\\n            add_header Access-Control-Allow-Credentials true;\\n            add_header Access-Control-Allow-Headers $http_access_control_request_headers;\\n            add_header Access-Control-Max-Age 1728000;\\n            return 204;\\n        }\\n    }\\n\\n    ...\\n}\\n复制代码\\n网络协议\\n\\n\\nTCP\\n传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由 IETF 的 RFC 793 定义。\\n\\n基于流的方式\\n面向连接\\n丢包重传\\n保证数据顺序\\nUDP\\nInternet 协议集支持一个无连接的传输协议，该协议称为用户数据报协议（UDP，User Datagram Protocol）。UDP 为应用程序提供了一种无需建立连接就可以发送封装的 IP 数据包的方法。RFC 768 描述了 UDP。\\n\\nUDP 是非连接的协议，也就是不会跟终端建立连接\\nUDP 包信息只有 8 个字节\\nUDP 是面向报文的。既不拆分，也不合并，而是保留这些报文的边界\\nUDP 可能丢包\\nUDP 不保证数据顺序\\nHTTP\\nHTTP/0.9：GET，无状态的特点形成\\n\\nHTTP/1.0：支持 POST，HEAD，添加了请求头和响应头，支持任何格式的文件发送，添加了状态码、多字符集支持、多部分发送、权限、缓存、内容编码等\\n\\nHTTP/1.1：默认长连接，同时 6 个 TCP 连接，CDN 域名分片\\n\\nHTTPS：HTTP + TLS（ 非对称加密 与 对称加密 ）\\n\\n客户端发出 https 请求，请求服务端建立 SSL 连接\\n服务端收到 https 请求，申请或自制数字证书，得到公钥和服务端私钥，并将公钥发送给客户端\\n户端验证公钥，不通过验证则发出警告，通过验证则产生一个随机的客户端私钥\\n客户端将公钥与客户端私钥进行对称加密后传给服务端\\n服务端收到加密内容后，通过服务端私钥进行非对称解密，得到客户端私钥\\n服务端将客户端私钥和内容进行对称加密，并将加密内容发送给客户端\\n客户端收到加密内容后，通过客户端私钥进行对称解密，得到内容\\nHTTP/2.0：多路复用（一次 TCP 连接可以处理多个请求），服务器主动推送，stream 传输。\\n\\nHTTP/3：基于 UDP 实现了 QUIC 协议\\n\\n建立好 HTTP2 连接\\n发送 HTTP2 扩展帧\\n使用 QUIC 建立连接\\n如果成功就断开 HTTP2 连接\\n升级为 HTTP3 连接\\n注：RTT = Round-trip time\\n\\n')])])]),t(\"h2\",{attrs:{id:\"渲染流程\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#渲染流程\"}},[n._v(\"#\")]),n._v(\" 渲染流程\")]),n._v(\" \"),t(\"p\",[n._v(\"构建 DOM 树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成\")]),n._v(\" \"),t(\"p\",[n._v(\"创建 DOM tree\")]),n._v(\" \"),t(\"p\",[n._v(\"遍历 DOM 树中的所有可见节点，并把这些节点加到布局树中。\\n不可见的节点会被布局树忽略掉。\")]),n._v(\" \"),t(\"p\",[n._v(\"样式计算\")]),n._v(\" \"),t(\"p\",[n._v(\"创建 CSSOM tree\\n转换样式表中的属性值\\n计算出 DOM 节点样式\")]),n._v(\" \"),t(\"p\",[n._v(\"生成 layout tree\")]),n._v(\" \"),t(\"p\",[n._v(\"分层\")]),n._v(\" \"),t(\"p\",[n._v(\"生成图层树（LayerTree）\\n拥有层叠上下文属性的元素会被提升为单独的一层\\n需要剪裁（clip）的地方也会被创建为图层\\n图层绘制\")]),n._v(\" \"),t(\"p\",[n._v(\"将图层转换为位图\")]),n._v(\" \"),t(\"p\",[n._v(\"合成位图并显示在页面中\")]),n._v(\" \"),t(\"h2\",{attrs:{id:\"隐式转换规则\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#隐式转换规则\"}},[n._v(\"#\")]),n._v(\" 隐式转换规则\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v('转换为原始类型\\n对象在转换类型的时候，会执行原生方法 ToPrimitive 。\\n其算法如下：\\n\\n如果已经是 原始类型，则返回当前值；\\n如果需要转 字符串 则先调用toSting方法，如果此时是 原始类型 则直接返回，否则再调用valueOf方法并返回结果；\\n如果不是 字符串，则先调用valueOf方法，如果此时是 原始类型 则直接返回，否则再调用toString方法并返回结果；\\n如果都没有 原始类型 返回，则抛出 TypeError 类型错误。\\n\\n当然，我们可以通过重写Symbol.toPrimitive来制定转换规则，此方法在转原始类型时调用优先级最高。\\nconst data = {\\n  valueOf() {\\n    return 1;\\n  },\\n  toString() {\\n    return \"1\";\\n  },\\n  [Symbol.toPrimitive]() {\\n    return 2;\\n  }\\n};\\ndata + 1; // 3\\n\\n转换为数字\\n对象转换为数字的规则如下表：\\n参数类型        结果\\nUndefined返回    NaN。\\nNull         Return +0.\\nBoolean      如果参数为 true，则返回 1；false则返回 +0。\\nNumber       返回当前参数。\\nString       先调用 ToPrimitive ，再调用 ToNumber ，然后返回结果。\\nSymbol       抛出 TypeError错误。\\nObject      先调用 ToPrimitive ，再调用 ToNumber ，然后返回结果。\\n\\n\\n转换为字符串\\n对象转换为字符串的规则如下表：\\n\\n参数类型            结果\\nUndefined      返回 \"undefined\"。\\nNull         返回 \"null\"。\\nBoolean      如果参数为 true ,则返回 \"true\"；否则返回 \"false\"。\\nNumber      调用 NumberToString ，然后返回结果。\\nString       返回 当前参数。\\nSymbol      抛出 TypeError错误。\\nObject      先调用 ToPrimitive ，再调用 ToString ，然后返回结果。\\n\\n\\n')])])]),t(\"h2\",{attrs:{id:\"this\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#this\"}},[n._v(\"#\")]),n._v(\" this\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"this 是和执行上下文绑定的。\\n执行上下文：\\n\\n全局执行上下文：全局执行上下文中的 this 也是指向 window 对象。\\n函数执行上下文：使用对象来调用其内部的一个方法，该方法的 this 是指向对象本身的。\\neval 执行上下文：执行 eval 环境内部的上两个情况。\\n\\n根据优先级最高的来决定 this 最终指向哪里。\\n首先，new 的方式优先级最高，接下来是 bind 这些函数，然后是 obj.foo() 这种调用方式，最后是 foo 这种调用方式，同时，箭头函数的 this 一旦被绑定，就不会再被任何方式所改变。\\n三点注意：\\n\\n1. 当函数作为对象的方法调用时，函数中的 this 就是该对象；\\n2. 当函数被正常调用时，在严格模式下，this 值是 undefined，非严格模式下 this 指向的是全局对象 window；\\n3. 嵌套函数中的 this 不会继承外层函数的 this 值。\\n4. 我们还提了一下箭头函数，因为箭头函数没有自己的执行上下文，所以箭头函数的 this 就是它外层函数的 this。\\n\\n\")])])]),t(\"h2\",{attrs:{id:\"原型-proto\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#原型-proto\"}},[n._v(\"#\")]),n._v(\" 原型 \"),t(\"strong\",[n._v(\"proto\")])]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"其实每个 JS 对象都有 __proto__ 属性，这个属性指向了原型。\\n原型也是一个对象，并且这个对象中包含了很多函数，对于 obj 来说，可以通过 __proto__ 找到一个原型对象，在该对象中定义了很多函数让我们来使用。\\n原型链：\\n\\nObject 是所有对象的爸爸，所有对象都可以通过 __proto__ 找到它\\nFunction 是所有函数的爸爸，所有函数都可以通过 __proto__ 找到它\\n函数的 prototype 是一个对象\\n对象的 __proto__ 属性指向原型， __proto__ 将对象和原型连接起来组成了原型链\\n\")])])]),t(\"h2\",{attrs:{id:\"v8工作原理\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#v8工作原理\"}},[n._v(\"#\")]),n._v(\" V8工作原理\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"数据存储\\n栈空间：先进后出的数据结构，调用栈，存储执行上下文，以及存储原始类型的数据。\\n堆空间：用数组实现的二叉树，存储引用类型。堆空间很大，能存放很多大的数据。存放在堆内存中的对象，变量实际保存的是一个指针，这个指针指向另一个位置。\\n\\n原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址。\\n\\n\\n垃圾回收\\n\\n\\n回收调用栈内的数据：执行上下文结束且没有被引用时，则会通过向下移动 记录当前执行状态的指针（称为 ESP） 来销毁该函数保存在栈中的执行上下文。\\n\\n\\n回收堆里的数据：\\n\\n    V8 中会把堆分为新生代和老生代两个区域，\\n    新生代中存放的是生存时间短的对象，\\n    老生代中存放的生存时间久的对象。\\n    垃圾回收重要术语：\\n\\n    代际假说\\n\\n    大部分对象在内存中存在的时间很短\\n    不死的对象，会活得更久\\n\\n    分代收集\\n\\n\\n副垃圾回收器：\\n主要负责新生代的垃圾回收。\\n这个区域不大，但是垃圾回收比较频繁。\\n新生代的垃圾回收算法是 Scavenge 算法。\\n主要把新生代空间对半划分为两个区域：对象区域，空闲区域。\\n当对象区域快被写满时，则会进行一次垃圾清理。\\n流程如下：\\n\\n对对象区域中的垃圾做标记\\n把存活的对象复制到空闲区域中\\n把这些对象有序地排列起来\\n清理完之后，对象区域会与空闲区域互换\\n\\n主垃圾回收器：\\n主垃圾回收器主要负责老生区中的垃圾回收。\\n除了新生区中晋升的对象，一些大的对象会直接被分配到老生区。\\n因此老生区中的对象有两个特点，一个是对象占用空间大，另一个是对象存活时间长。\\n流程如下：\\n\\n从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，区分活动对象以及垃圾数据\\n标记过程和清除过程使用标记 - 清除算法\\n碎片过多会导致大对象无法分配到足够的连续内存时，会使用标记 - 整理算法\\n\\n一旦执行垃圾回收算法，会导致 全停顿（Stop-The-World） 。\\n但是 V8 有 增量标记算法 。\\nV8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成。\\n\\n\\n\")])])]),t(\"h2\",{attrs:{id:\"浏览器安全\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#浏览器安全\"}},[n._v(\"#\")]),n._v(\" 浏览器安全\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v('攻击方式\\n\\n\\nxss：将代码注入到网页\\n\\n持久型 ：写入数据库\\n非持久型 ：修改用户代码\\n\\n\\n\\ncsrf：跨站请求伪造。攻击者会虚构一个后端请求地址，诱导用户通过某些途径发送请求。\\n\\n\\n中间人攻击：中间人攻击是攻击方同时与服务端和客户端建立起了连接，并让对方认为连接是安全的，但是实际上整个通信过程都被攻击者控制了。攻击者不仅能获得双方的通信信息，还能修改通信信息。\\n\\nDNS 欺骗：入侵 DNS 来将用户访问目标改为入侵者指定机器\\n会话劫持：在一次正常的通信过程中，攻击者作为第三方参与到其中，或者是在数据里加入其他信息，甚至将双方的通信模式暗中改变，即从直接联系变成有攻击者参与的联系。\\n\\n\\n防御措施\\n\\n预防 XSS\\n\\n\\n\\n使用转义字符过滤 html 代码\\nconst escapeHTML = value => {\\n  if (!value || !value.length) {\\n    return value;\\n  }\\n  return value\\n    .replace(/&/g, \"&amp;\")\\n    .replace(/</g, \"&lt;\")\\n    .replace(/>/g, \"&gt;\")\\n    .replace(/\"/g, \"&quot;\")\\n    .replace(/\\'/g, \"&#39;\");\\n};\\n复制代码\\n\\n\\n过滤 SQL 代码\\nconst replaceSql = value => {\\n  if (!value || !value.length) {\\n    return value;\\n  }\\n  return value.replace(/select|update|delete|exec|count|\\'|\"|=|;|>|<|%/gi, \"\");\\n};\\n复制代码\\n\\n\\n\\n\\n预防 CSRF\\n\\n验证 HTTP Referer 字段\\n在请求地址中添加 token 并验证\\n在 HTTP 头中自定义属性并验证\\nGet 请求不对数据进行修改\\n接口防跨域处理\\n不让第三方网站访问用户 cookie\\n\\n\\n\\n预防中间人攻击\\n\\n\\n\\n对于 DNS 欺骗：检查本机的 HOSTS 文件\\n对于会话劫持：使用交换式网络代替共享式网络，还必须使用静态 ARP、捆绑 MAC+IP 等方法来限制欺骗，以及采用认证方式的连接等。\\n\\n\\n内容安全策略（CSP）\\n\\n内容安全策略 (CSP) 是一个额外的安全层，用于检测并削弱某些特定类型的攻击，包括跨站脚本 (XSS) 和数据注入攻击等。无论是数据盗取、网站内容污染还是散发恶意软件，这些攻击都是主要的手段。\\n措施如下：\\n\\nHTTP Header 中的 Content-Security-Policy\\n<meta http-equiv=\"Content-Security-Policy\">\\n\\n\\n\\n')])])]),t(\"h2\",{attrs:{id:\"缓存\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#缓存\"}},[n._v(\"#\")]),n._v(\" 缓存\")]),n._v(\" \"),t(\"p\",[n._v(\"https://juejin.cn/post/6844904166591070222#heading-27\")]),n._v(\" \"),t(\"h2\",{attrs:{id:\"普通函数和箭头函数的区别\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#普通函数和箭头函数的区别\"}},[n._v(\"#\")]),n._v(\" 普通函数和箭头函数的区别：\")]),n._v(\" \"),t(\"p\",[n._v(\"1、箭头函数不可作为构造函数，不能使用new\\n2、箭头函数没有自己的this\\n3、箭头函数没有arguments对象\\n4、箭头函数没有原型对象\")]),n._v(\" \"),t(\"h2\",{attrs:{id:\"for-await-of\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#for-await-of\"}},[n._v(\"#\")]),n._v(\" for await of\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"function fn (time) {\\n  return new Promise((resolve, reject) => {\\n    setTimeout(() => {\\n      resolve(`${time}毫秒后我成功啦！！！`)\\n    }, time)\\n  })\\n}\\n\\nasync function asyncFn () {\\n  const arr = [fn(3000), fn(1000), fn(1000), fn(2000), fn(500)]\\n  for await (let x of arr) {\\n    console.log(x)\\n  }\\n}\\n\\nasyncFn()\\n3000毫秒后我成功啦！！！\\n1000毫秒后我成功啦！！！\\n1000毫秒后我成功啦！！！\\n2000毫秒后我成功啦！！！\\n500毫秒后我成功啦！！！\\n\\n\")])])]),t(\"h2\",{attrs:{id:\"promise-finally\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#promise-finally\"}},[n._v(\"#\")]),n._v(\" promise.finally\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"// cheng\\nnew Promise((resolve, reject) => {\\n  resolve('成功喽')\\n}).then(\\n  res => { console.log(res) },\\n  err => { console.log(err) }\\n).finally(() => { console.log('我是finally') })\\n\\nnew Promise((resolve, reject) => {\\n  reject('失败喽')\\n}).then(\\n  res => { console.log(res) },\\n  err => { console.log(err) }\\n).finally(() => { console.log('我是finally') })\\n\\n\")])])]),t(\"h2\",{attrs:{id:\"promise-allsettled\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#promise-allsettled\"}},[n._v(\"#\")]),n._v(\" Promise.allSettled\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"\\nES11新增的Promise的方法\\n\\n接收一个Promise数组，数组中如有非Promise项，则此项当做成功\\n把每一个Promise的结果，集合成数组，返回\\n\\nfunction fn(time, isResolve) {\\n  return new Promise((resolve, reject) => {\\n    setTimeout(() => {\\n      isResolve ? resolve(`${time}毫秒后我成功啦！！！`) : reject(`${time}毫秒后我失败啦！！！`)\\n    }, time)\\n  })\\n}\\n\\nPromise.allSettled([fn(2000, true), fn(3000), fn(1000)]).then(res => {\\n  console.log(res)\\n  // 3秒后输出\\n  [\\n  { status: 'fulfilled', value: '2000毫秒后我成功啦！！！' },\\n  { status: 'rejected', reason: '3000毫秒后我失败啦！！！' },\\n  { status: 'rejected', reason: '1000毫秒后我失败啦！！！' }\\n]\\n})\\n\\n\\n\")])])]),t(\"h2\",{attrs:{id:\"promise-any\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#promise-any\"}},[n._v(\"#\")]),n._v(\" Promise.any\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"E12新增的Promise的方法\\n\\n接收一个Promise数组，数组中如有非Promise项，则此项当做成功\\n如果有一个Promise成功，则返回这个成功结果\\n如果所有Promise都失败，则报错\\n\\n\\n// 当有成功的时候，返回最快那个成功\\nfunction fn(time, isResolve) {\\n  return new Promise((resolve, reject) => {\\n    setTimeout(() => {\\n      isResolve ? resolve(`${time}毫秒后我成功啦！！！`) : reject(`${time}毫秒后我失败啦！！！`)\\n    }, time)\\n  })\\n}\\n\\nPromise.any([fn(2000, true), fn(3000), fn(1000, true)]).then(res => {\\n  console.log(res) // 1秒后 输出  1000毫秒后我成功啦\\n}, err => {\\n  console.log(err)\\n})\\n\\n// 当全都失败时\\nfunction fn(time, isResolve) {\\n  return new Promise((resolve, reject) => {\\n    setTimeout(() => {\\n      isResolve ? resolve(`${time}毫秒后我成功啦！！！`) : reject(`${time}毫秒后我失败啦！！！`)\\n    }, time)\\n  })\\n}\\n\\nPromise.any([fn(2000), fn(3000), fn(1000)]).then(res => {\\n  console.log(res)\\n}, err => {\\n  console.log(err) // 3秒后 报错 all Error\\n})\\n\\n\")])])]),t(\"h2\",{attrs:{id:\"array-flatmap\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#array-flatmap\"}},[n._v(\"#\")]),n._v(\" Array.flatMap\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"let arr = [\\\"科比 詹姆斯 安东尼\\\", \\\"利拉德 罗斯 麦科勒姆\\\"];\\nconsole.log(arr.flatMap(x => x.split(\\\" \\\")));\\n// [ '科比', '詹姆斯', '安东尼', '利拉德', '罗斯', '麦科勒姆' ]\\n\")])])]),t(\"h2\",{attrs:{id:\"object-fromentries\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#object-fromentries\"}},[n._v(\"#\")]),n._v(\" Object.fromEntries\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"前面ES8的Object.entries是把对象转成键值对数组，而Object.fromEntries则相反，是把键值对数组转为对象\\n\\nconst arr = [\\n  ['name', '林三心'],\\n  ['age', 22],\\n  ['gender', '男']\\n]\\n\\nconsole.log(Object.fromEntries(arr)) // { name: '林三心', age: 22, gender: '男' }\\n\\n\\n把Map 转为对象\\n\\nconst map = new Map()\\nmap.set('name', '林三心')\\nmap.set('age', 22)\\nmap.set('gender', '男')\\n\\nconsole.log(map) // Map(3) { 'name' => '林三心', 'age' => 22, 'gender' => '男' }\\n\\nconst obj = Object.fromEntries(map)\\nconsole.log(obj) // { name: '林三心', age: 22, gender: '男' }\\n\\n\")])])]),t(\"h2\",{attrs:{id:\"string-trimstart-string-trimend\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#string-trimstart-string-trimend\"}},[n._v(\"#\")]),n._v(\" String.trimStart && String.trimEnd\")]),n._v(\" \"),t(\"h2\",{attrs:{id:\"\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#\"}},[n._v(\"#\")]),n._v(\" ??\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"??和||最大的区别是，在??这，只有undefined和null才算假值\\nconst a = 0 ?? '林三心' // 0\\nconst b = '' ?? '林三心' // ''\\nconst c = false ?? '林三心' // false\\nconst d = undefined ?? '林三心' // 林三心\\nconst e = null ?? '林三心' // 林三心\\n\\n\")])])])])}),[],!1,null,null,null);e.default=r.exports}}]);","extractedComments":[]}