{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[356],{898:function(n,t,a){\"use strict\";a.r(t);var i=a(12),s=Object(i.a)({},(function(){var n=this,t=n.$createElement,a=n._self._c||t;return a(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":n.$parent.slotKey}},[a(\"h4\",{attrs:{id:\"git-常用命令总结\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#git-常用命令总结\"}},[n._v(\"#\")]),n._v(\" git 常用命令总结\")]),n._v(\" \"),a(\"h5\",{attrs:{id:\"基本命令\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#基本命令\"}},[n._v(\"#\")]),n._v(\" 基本命令\")]),n._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v('1、git init\\n2、git remote add origin http://192.168.10.250/t3-web-frontend/t3-web-operation.git\\n拉取远程分支\\n3、git fetch origin dev-xxx\\n 根据远程分支创建本地分支,并切换到当前分支\\n4、git checkout -b dev20190622 origin/dev-xxx\\n\\n修改代码\\n6、git status\\n7、git add vue.config.js\\n8、git diff vue.config.js\\n9、git commit -m \"注释\"\\n推送远程\\n10、git push origin dev20190622:dev-xxx\\n11、git log\\n12、git checkout dev20190623\\n\\ngit push <远程主机名> <本地分支名>  <远程分支名>\\n例如 git push origin master：refs/for/master ，\\n即是将本地的master分支推送到远程主机origin上的对应master分支， origin 是远程主机名，\\n\\n第一个master是本地分支名，第二个master是远程分支名。\\n\\n    1.1 git push origin master\\n\\n    如果远程分支被省略，如上则表示将本地分支推送到与之存在追踪关系的远程分支\\n    （通常两者同名），如果该远程分支不存在，则会被新建\\n\\n     1.2 git push origin ：refs/for/master \\n\\n　　如果省略本地分支名，则表示删除指定的远程分支，\\n　　因为这等同于推送一个空的本地分支到远程分支，等同于 git push origin --delete master\\n\\n    1.3 git push origin\\n\\n　　 如果当前分支与远程分支存在追踪关系，则本地分支和远程分支都可以省略，\\n　　 将当前分支推送到origin主机的对应分支 \\n\\n　1.4 git push\\n\\n　　如果当前分支只有一个远程分支，那么主机名都可以省略，形如 git push，可以使用git branch -r ，查看远程的分支名\\n\\n')])])]),a(\"h2\",{attrs:{id:\"git-rm\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#git-rm\"}},[n._v(\"#\")]),n._v(\" git rm\")]),n._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v(\"移除cache 状态, \\ngit rm --cache 文件名\\n\\n移除cache 状态, 并直接删除\\ngit rm -f 文件名\\n\\n\")])])]),a(\"h2\",{attrs:{id:\"git-reset\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#git-reset\"}},[n._v(\"#\")]),n._v(\" git reset\")]),n._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v(\"取消暂存的文件\\ngit reset HEAD 文件名1 文件名2 ...\\n\\n撤消对文件的修改\\ngit checkout -- 文件名\\n\\n\\n工作区域\\n\\n暂存区域\\n\\n提交的历史\\n\\ngit reset\\n\\n三种模式 soft,mixed,hard\\n\")])])]),a(\"h2\",{attrs:{id:\"git-branch\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#git-branch\"}},[n._v(\"#\")]),n._v(\" git branch\")]),n._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v(\"查看远程分支\\ngit branch -r\\n\\n创建分支\\ngit branch 分支名\\n\\n删除分支\\ngit branch -D 分支名\\n\\n切换分支\\ngit checkout 分支名\\n\\n创建和切换合起来\\ngit checkout -b iss53\\n相等于\\n$ git branch iss53\\n$ git checkout iss53\\n\\n合并分支\\ngit merge 覆盖分支名\\n\\n如果有冲突, 先解决冲突,然后commit\\n\\n\\n需要查看每一个分支的最后一次提交\\ngit branch -v \\n\\n创建一个本地分支跟踪远程分支:\\n1. serverfix 分支上工作，可以将其建立在远程跟踪分支之上\\ngit checkout -b serverfix origin/serverfix\\n\\n2. 快捷方式\\ngit checkout --track origin/serverfix\\n\\n如果想要将本地分支与远程分支设置为不同名字\\ngit checkout -b 别名 origin/serverfix\\n\\n⭐️\\n设置已有的本地分支跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的上游分支，\\n你可以在任意时间使用 -u 或 --set-upstream-to 选项运行 git branch 来显式地设置。\\n\\n$ git branch -u origin/serverfix\\n\\n\\n想要查看设置的所有跟踪分支，可以使用 git branch 的 -vv 选项。 \\n这会将所有的本地分支列出来并且包含更多的信息，\\n如每一个分支正在跟踪哪个远程分支与本地分支是否是领先、落后\\ngit branch -vv\\n\\n\\ngit pull 大多数情况等于 git fetch + git merge\\n\\n删除远程分支\\ngit push origin --delete 分支名\\n\\n\\n\")])])]),a(\"h2\",{attrs:{id:\"tag\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#tag\"}},[n._v(\"#\")]),n._v(\" tag\")]),n._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v(\"查询tag\\ngit tag\\n\\n关键字查询tag\\ngit tag -l 'develop_v*'\\n\\n创建tag\\ngit tag -a tag名 -m \\\"注释内容\\\"\\n轻量标签: 不需要使用 -a、-s 或 -m 选项，只需要提供标签名字\\n\\n删除标签\\ngit tag -d <tagname>\\n本地tag删除了，再执行该句，删除线上tag\\ngit push origin :refs/tags/v1.4-lw\\n\\n标签信息与对应的提交信息：\\ngit show tag名\\n\\n基于tag 创建新分支:\\ngit checkout -b 分支名 tag名\\n\\n拉取远程tag\\ngit fetch origin tag tag名\\n\\n推送tag到远程\\ngit push origin --tags\\n\\n\")])])]),a(\"h2\",{attrs:{id:\"git-config\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#git-config\"}},[n._v(\"#\")]),n._v(\" git config\")]),n._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v(\"$ git config --global alias.co checkout\\n$ git config --global alias.br branch\\n$ git config --global alias.ci commit\\n$ git config --global alias.st status\\n\\n取消暂存文件\\ngit config --global alias.unstage 'reset HEAD --'\\n\\n$ git config --global alias.last 'log -1 HEAD'\\n\\n演示将 git visual 定义为 gitk 的别名：\\n$ git config --global alias.visual '!gitk'\\n\\n取消别名\\ngit config --global --unset alias.st\\n\\n\")])])]),a(\"h2\",{attrs:{id:\"git-mv\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#git-mv\"}},[n._v(\"#\")]),n._v(\" git mv\")]),n._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v(\"其实，运行 git mv 就相当于运行了下面三条命令：\\n\\n$ mv README.md README\\n$ git rm README.md\\n$ git add README\\n\")])])]),a(\"h2\",{attrs:{id:\"git-log\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#git-log\"}},[n._v(\"#\")]),n._v(\" git log\")]),n._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v('一个常用的选项是 -p，用来显示每次提交的内容差异。 你也可以加上 -2 来仅显示最近两次提交：\\ngit log -p -2\\n\\n看简略的信息\\ngit log --stat\\n\\ngit log --pretty=oneline\\n\\n查看每次提交的详细时间\\ngit log --pretty=format:\"%h - %an, %ad : %s\"\\n\\ngit log --since=2.weeks\\n\\n-(n)\\n\\n仅显示最近的 n 条提交\\n\\n--since, --after\\n\\n仅显示指定时间之后的提交。\\n\\n--until, --before\\n\\n仅显示指定时间之前的提交。\\n\\n')])])]),a(\"h2\",{attrs:{id:\"git-commit\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#git-commit\"}},[n._v(\"#\")]),n._v(\" git commit\")]),n._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v(\"有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 \\n此时，可以运行带有 --amend 选项的提交命令尝试重新提交：\\n\\n$ git commit --amend\\n\\n这个命令会将暂存区中的文件提交。\\n\\n$ git commit -m 'initial commit'\\n$ git add forgotten_file\\n$ git commit --amend\\n最终你只会有一个提交——第二次提交将代替第一次提交的结果。\\n\\n取消暂存的文件\\ngit reset HEAD [filename]\\n\\n撤销文件的修改\\ngit checkout -- [filename]\\n\\n\")])])]),a(\"h2\",{attrs:{id:\"git-tag\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#git-tag\"}},[n._v(\"#\")]),n._v(\" git tag\")]),n._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v(\"创建tag\\n\\n轻量标签\\ngit tag [tag-name]\\n\\n带描述信息\\ngit tag -a [tag-name] -m \\\"[message]\\\"\\n\\n\\ntag 列表\\ngit tag\\n\\n只对 1.8.5 系列感兴趣\\ngit tag -l 'v1.8.5*'\\n\\n\\ntag 提交信息\\ngit show [tag-name]\\n\\n删除本地标签\\ngit tag -d v1.4-lw\\n\\n更新远程仓库标签\\ngit push origin :refs/tags/v1.4-lw\\n\\n\")])])]),a(\"h2\",{attrs:{id:\"git-branch-2\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#git-branch-2\"}},[n._v(\"#\")]),n._v(\" git branch\")]),n._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v(\"分支创建\\ngit branch [branch-name]\\n\\n分支切换\\ngit checkout [branch-name]\\n\\n\\ngit checkout -b [branch-name] \\n==\\ngit branch [branch-name]\\ngit checkout [branch-name]\\n\\n\\n查看每个分支最后一次提交\\ngit branch -v\\n\\n\\n查看哪些分支已经合到当前分支\\ngit branch --merged\\n\\n查看哪些分支未合到当前分支\\ngit branch --no-merged\\n\\n删除远程分支\\ngit push origin --delete serverfix\\n\\n\\n\\n分支变基\\ngit rebase [basebranch] [topicbranch] \\n\\ngit checkout [experiment]\\ngit rebase master\\n(它的原理是首先找到这两个分支（即当前分支 experiment、变基操作的目标基底分支 master）的最近共同祖先 C2，\\n然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件，\\n然后将当前分支指向目标基底 C3, 最后以此将之前另存为临时文件的修改依序应用)\\n\\n将 C4 中的修改变基到 C3 上\\n现在回到 master 分支，进行一次快进合并。\\n\\n$ git checkout master\\n$ git merge experiment\\n\\n你在查看一个经过变基的分支的历史记录时会发现，尽管实际的开发工作是并行的，但它们看上去就像是串行的一样，提交历史是一条直线没有分叉。\\n\\n\")])])]),a(\"h1\",{attrs:{id:\"git-config-2\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#git-config-2\"}},[n._v(\"#\")]),n._v(\" git config\")]),n._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v(\"\\n\\ngit config --list\\n\\n命令别名\\n$ git config --global alias.co checkout\\n$ git config --global alias.br branch\\n$ git config --global alias.ci commit\\n$ git config --global alias.st status\\n\\nalias.st=status\\nalias.co=checkout\\nalias.br=branch\\nalias.ci=commit\\nalias.df=diff\\n\\n\\n// 删除别名\\ngit config --global --unset alias.l\\n\\n// 删除所有别名\\ngit config --global --remove-section alias\\n\\n\\n\\n\\ngit clone [url] [本地仓库名]\\n\\n查看远程仓库\\ngit remove -v\\n\\n\\n重命名远程仓库\\ngit remote rename [name1] [destname]\\n\\n删除远程仓库\\ngit remote rm [remote-name]\\n\\n\\n\")])])]),a(\"h1\",{attrs:{id:\"git-stash\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#git-stash\"}},[n._v(\"#\")]),n._v(\" git stash\")]),n._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v(\"\\n默认情况下，git stash 只会储藏已经在索引中的文件。 \\n\\ngit stash\\n\\n// 如果指定 --include-untracked 或 -u 标记，Git 也会储藏任何创建的未跟踪文件。\\ngit stash -u  或 git stash --unclude-untracked\\n\\n\\n// 查看存储的\\ngit stash list\\n\\n如果不指定一个储藏，Git 认为指定的是最近的储藏\\ngit stash apply\\n\\ngit stash apply stash@{2}\\n\\n// 从栈顶弹出一个\\ngit stash pop\\n\\n\\n// 从栈里直接丢弃\\ngit stash drop stash@{0}\\n\\ngit stash show  stash@{$num}  -p\\n\\n\\n常规 git stash 的一个限制是它会一下暂存所有的文件。有时，只备份某些文件更为方便，让另外一些与代码库保持一致。一个非常有用的技巧，用来备份部分文件：\\n\\n它告诉 Git 不要储藏任何你通过 git add 命令已暂存的东西\\n\\nadd 那些你不想备份的文件（例如： git add file1.js, file2.js）\\n调用 git stash –-keep-index。只会备份那些没有被add的文件。\\n调用 git reset 取消已经add的文件的备份，继续自己的工作。\\n\\n\\n场景\\n开发到一半,同步远端代码\\n工作流被打断,需要先做别的需求\\n\\n\\n\")])])]),a(\"p\",[n._v(\"HEAD 是当前分支引用的指针，它总是指向该分支上的最后一次提交。\")]),n._v(\" \"),a(\"p\",[n._v(\"从根本上来讲 Git 是一个内容寻址（content-addressable）文件系统\")]),n._v(\" \"),a(\"h1\",{attrs:{id:\"git-grep\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#git-grep\"}},[n._v(\"#\")]),n._v(\" git grep\")]),n._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v(\"git grep [关键字]\\n\\n-n 显示行号 \\ngit grep -n [关键字] [分支名]\\n\\n只显示文件名\\ngit grep --name-only [关键字]\\n\\n\")])])])])}),[],!1,null,null,null);t.default=s.exports}}]);","extractedComments":[]}