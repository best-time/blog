{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[288],{828:function(t,e,a){\"use strict\";a.r(e);var r=a(12),s=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":t.$parent.slotKey}},[a(\"h3\",{attrs:{id:\"疑问\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#疑问\"}},[t._v(\"#\")]),t._v(\" 疑问\")]),t._v(\" \"),a(\"blockquote\",[a(\"p\",[t._v(\"在知乎上提了个 \"),a(\"a\",{attrs:{href:\"https://www.zhihu.com/question/297323663\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"使用 immutable.js 后有什么优势？\"),a(\"OutboundLink\")],1)])]),t._v(\" \"),a(\"h3\",{attrs:{id:\"自答\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#自答\"}},[t._v(\"#\")]),t._v(\" 自答\")]),t._v(\" \"),a(\"p\",[t._v(\"假如要更新 4, immutable.js 只在绿色这条线做了特殊处理, 其它紫色的部分保持不变。相当于是优化了深拷贝的实现, 数据结构方面可以想象成链表, 因此在深拷贝的时候没有递归那么耗费性能, 同时也更利于数据的获取。\")]),t._v(\" \"),a(\"p\",[t._v(\"因为最顶部的对象变化了, React 就提前知道需要重新渲染了(可以弥补 PureComponent 只作浅比较的不足)。不过 Updated tree 里的每一个节点还是会重新 diff 的, 不过在数据前后比较的这个层面上讲, immutable.js 的效率确实会高一些。\")]),t._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"http://with.muyunyun.cn/aeef08a94abebda30e9a5fa68e201fa8.jpg\",alt:\"\"}})]),t._v(\" \"),a(\"p\",[t._v(\"另外, 使用 immutable.js 的话需要将所有的 state,props 都转化成其定义的形式。成本还是有的。\")])])}),[],!1,null,null,null);e.default=s.exports}}]);","extractedComments":[]}