{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[379],{921:function(n,t,e){\"use strict\";e.r(t);var a=e(12),o=Object(a.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":n.$parent.slotKey}},[e(\"h1\",{attrs:{id:\"cdn\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#cdn\"}},[n._v(\"#\")]),n._v(\" cdn\")]),n._v(\" \"),e(\"p\",[n._v(\"https://mp.weixin.qq.com/s/nES0HWRyTVg05sfxj25WJQ\")]),n._v(\" \"),e(\"p\",[n._v(\"「构建策略」：基于构建工具(Webpack/Rollup/Parcel/Esbuild/Vite/Gulp)\\n「图像策略」：基于图像类型(JPG/PNG/SVG/WebP/Base64)\\n「分发策略」：基于内容分发网络(CDN)\\n「缓存策略」：基于浏览器缓存(强缓存/协商缓存)\")]),n._v(\" \"),e(\"p\",[n._v(\"该策略主要围绕内容分发网络做相关处理，同时也是接入成本较高的性能优化策略，需足够资金支持。\\n虽然接入成本较高，但大部分企业都会购买一些CDN服务器，所以在部署的事情上就不用过分担忧，尽管使用就好。该策略尽量遵循以下两点就能发挥CDN最大作用。\")]),n._v(\" \"),e(\"p\",[n._v(\"「所有静态资源走CDN」：开发阶段确定哪些文件属于静态资源\\n「把静态资源与主页面置于不同域名下」：避免请求带上Cookie\")]),n._v(\" \"),e(\"p\",[n._v(\"「内容分发网络」简称「CDN」，指一组分布在各地存储数据副本并可根据就近原则满足数据请求的服务器。其核心特征是缓存和回源，缓存是把资源复制到CDN服务器里，回源是资源过期/不存在就向上层服务器请求并复制到CDN服务器里。\")]),n._v(\" \"),e(\"p\",[n._v(\"使用CDN可降低网络拥塞，提高用户访问响应速度和命中率。构建在现有网络基础上的智能虚拟网络，依靠部署在各地服务器，通过中心平台的调度、负载均衡、内容分发等功能模块，使用户就近获取所需资源，这就是CDN的终极使命。\")]),n._v(\" \"),e(\"p\",[n._v(\"基于CDN的「就近原则」所带来的优点，可将网站所有静态资源全部部署到CDN服务器里。那静态资源包括哪些文件？通常来说就是无需服务器产生计算就能得到的资源，例如不常变化的样式文件、脚本文件和多媒体文件(字体/图像/音频/视频)等。\")]),n._v(\" \"),e(\"p\",[n._v(\"为了让浏览器缓存发挥最大作用，该策略尽量遵循以下五点就能发挥浏览器缓存最大作用。\\n「考虑拒绝一切缓存策略」：Cache-Control:no-store\\n「考虑资源是否每次向服务器请求」：Cache-Control:no-cache\\n「考虑资源是否被代理服务器缓存」：Cache-Control:public/private\\n「考虑资源过期时间」：Expires:t/Cache-Control:max-age=t,s-maxage=t\\n「考虑协商缓存」：Last-Modified/Etag\")]),n._v(\" \"),e(\"p\",[n._v(\"整个缓存策略机制很明了，先走强缓存，若命中失败才走协商缓存。若命中强缓存，直接使用强缓存；若未命中强缓存，发送请求到服务器检查是否命中协商缓存；若命中协商缓存，服务器返回304通知浏览器使用本地缓存，否则返回最新资源。\\n有两种较常用的应用场景值得使用缓存策略一试，当然更多应用场景都可根据项目需求制定。\\n「频繁变动资源」：设置Cache-Control:no-cache，使浏览器每次都发送请求到服务器，配合Last-Modified/ETag验证资源是否有效\\n「不常变化资源」：设置Cache-Control:max-age=31536000，对文件名哈希处理，当代码修改后生成新的文件名，当HTML文件引入文件名发生改变才会下载最新文件\")]),n._v(\" \"),e(\"p\",[n._v(\"「渲染层面」的性能优化，无疑是如何让代码解析更好执行更快。因此笔者从以下五方面做出建议。\")]),n._v(\" \"),e(\"p\",[n._v(\"「CSS策略」：基于CSS规则\\n「DOM策略」：基于DOM操作\\n「阻塞策略」：基于脚本加载\\n「回流重绘策略」：基于回流重绘\\n「异步更新策略」：基于异步更新\")]),n._v(\" \"),e(\"p\",[n._v(\"上述五方面都是编写代码时完成，充满在整个项目流程的开发阶段里。因此在开发阶段需时刻注意以下涉及到的每一点，养成良好的开发习惯，性能优化也自然而然被使用上了。\\n渲染层面的性能优化更多表现在编码细节上，而并非实体代码。简单来说就是遵循某些编码规则，才能将渲染层面的性能优化发挥到最大作用。\")])])}),[],!1,null,null,null);t.default=o.exports}}]);","extractedComments":[]}