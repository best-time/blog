{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[130],{671:function(n,r,e){\"use strict\";e.r(r);var a=e(12),l=Object(a.a)({},(function(){var n=this.$createElement,r=this._self._c||n;return r(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":this.$parent.slotKey}},[r(\"p\",[this._v(\"归并排序的思路：\\n1.先左侧部分排好序\\n2.再右侧部分排好序\\n3.再准备一个辅助数组，用外排的方式，小的开始填，直到有个动到末尾，将另一个数组剩余部分拷贝到末尾\\n4.再将辅助数组拷贝回原数组\\n时间复杂度:O(N * logN)\\n空间复杂度:O(N)\")]),this._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[this._v(\"\\n// 递归实现\\n\\nfunction mergeSort(arr){\\n    if(arr == null  || arr.length <= 0){\\n        return [];\\n    }\\n    sortProcess(arr, 0, arr.length - 1);\\n    return arr;\\n}\\n\\nfunction sortProcess(arr, L, R){\\n    //递归的终止条件，就是左右边界索引一样\\n    if(L == R){\\n        return;\\n    }\\n    var middle = L + ((R - L) >> 1);//找出中间值\\n    sortProcess(arr, L, middle);//对左侧部分进行递归\\n    sortProcess(arr, middle + 1, R);//对右侧部分进行递归\\n    merge(arr, L, middle, R);//然后利用外排方式进行结合\\n}\\n\\nfunction merge(arr, L, middle, R){\\n    var help = [];\\n    var l = L;\\n    var r = middle + 1;\\n    var index = 0;\\n    //利用外排方式进行\\n    while(l <= middle && r <= R){\\n        help[index++] = arr[l] < arr[r] ? arr[l++] : arr[r++];\\n    }\\n    while(l <= middle){\\n        help.push(arr[l++]);\\n    }\\n    while(r <= R){\\n        help.push(arr[r++]);\\n    }\\n\\n    for(var i = 0; i < help.length; i++) {\\n        arr[L + i] = help[i];\\n    }\\n    //arr.splice(L, help.length, ...help);//这个利用了ES6的语法\\n}\\n\\n\")])])]),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[this._v(\"\\n// 循环实现\\n\\nfunction mergeSort(arr){\\n    if(arr ==null || arr.length <= 0){\\n        return [];\\n    }\\n    var len = arr.length;\\n    //i每次乘2，是因为每次合并以后小组元素就变成两倍个了\\n    for(var i = 1; i < len; i *= 2){\\n        var index = 0;//第一组的起始索引\\n        while( 2 * i  + index <= len){\\n            index += 2 * i;\\n            merge(arr, index - 2 * i, index - i, index);\\n        }\\n        //说明剩余两个小组，但其中一个小组数据的数量已经不足2的幂次方个\\n        if(index + i < len){\\n            merge(arr, index, index + i, len);\\n        }\\n    }\\n    return arr;\\n}\\n\\n\")])])]),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[this._v(\"//利用外排的方式进行结合\\nfunction merge(arr, start, mid, end){\\n    //新建一个辅助数组\\n    var help = [];\\n    var l = start, r = mid;\\n    var i = 0;\\n    while(l < mid && r < end){\\n        help[i++] = arr[l] < arr[r] ? arr[l++] : arr[r++];\\n    }\\n    while(l < mid){\\n        help[i++] = arr[l++];\\n    }\\n    while(r < end){\\n        help[i++] = arr[r++];\\n    }\\n    for(var j = 0; j < help.length; j++){\\n        arr[start + j] = help[j];\\n    }\\n}\\n\")])])])])}),[],!1,null,null,null);r.default=l.exports}}]);","extractedComments":[]}