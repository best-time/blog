{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{556:function(e,t,r){\"use strict\";r.r(t);var n=r(12),a=Object(n.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":e.$parent.slotKey}},[r(\"h2\",{attrs:{id:\"reflect\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#reflect\"}},[e._v(\"#\")]),e._v(\" Reflect\")]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v(\"\\nReflect.apply(target, thisArg, args)\\nReflect.construct(target, args)\\nReflect.get(target, name, receiver)\\nReflect.set(target, name, value, receiver)\\nReflect.defineProperty(target, name, desc)\\nReflect.deleteProperty(target, name)\\nReflect.has(target, name)\\nReflect.ownKeys(target)\\nReflect.isExtensible(target)\\nReflect.preventExtensions(target)\\nReflect.getOwnPropertyDescriptor(target, name)\\nReflect.getPrototypeOf(target)\\nReflect.setPrototypeOf(target, prototype)\\n\")])])]),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v(\"Reflect.defineProperty(target, property, attributes)\\n\\nReflect.has(Object, 'assign')\\n\\n\\n// 老写法\\nFunction.prototype.apply.call(Math.floor, undefined, [1.75]) // 1\\n\\n// 新写法\\nReflect.apply(Math.floor, undefined, [1.75]) // 1\\n\")])])]),r(\"h2\",{attrs:{id:\"reflect-get-target-name-receiver\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#reflect-get-target-name-receiver\"}},[e._v(\"#\")]),e._v(\" Reflect.get(target, name, receiver)\")]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v(\"\\n如果name属性部署了读取函数（getter），则读取函数的this绑定receiver。\\n\\nvar myObject = {\\n  foo: 1,\\n  bar: 2,\\n  get baz() {\\n    return this.foo + this.bar;\\n  },\\n};\\n\\nvar myReceiverObject = {\\n  foo: 4,\\n  bar: 4,\\n};\\n\\nReflect.get(myObject, 'baz', myReceiverObject) // 8\\n\")])])]),r(\"h2\",{attrs:{id:\"reflect-set-target-name-value-receiver\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#reflect-set-target-name-value-receiver\"}},[e._v(\"#\")]),e._v(\" Reflect.set(target, name, value, receiver)\")]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v(\"\\n如果name属性设置了赋值函数，则赋值函数的this绑定receiver。\\n\\nvar myObject = {\\n  foo: 4,\\n  set bar(value) {\\n    return this.foo = value;\\n  },\\n};\\n\\nvar myReceiverObject = {\\n  foo: 0,\\n};\\n\\nReflect.set(myObject, 'bar', 1, myReceiverObject);\\nmyObject.foo // 4\\nmyReceiverObject.foo // 1\\n\")])])]),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v(\"☆☆☆☆☆\\n注意，如果 Proxy对象和 Reflect对象联合使用，前者拦截赋值操作，后者完成赋值的默认行为，而且传入了receiver，那么Reflect.set会触发Proxy.defineProperty拦截。\\n\\nlet p = {\\n  a: 'a'\\n};\\n\\nlet handler = {\\n  set(target, key, value, receiver) {\\n    console.log('set');\\n    Reflect.set(target, key, value, receiver)\\n  },\\n  defineProperty(target, key, attribute) {\\n    console.log('defineProperty');\\n    Reflect.defineProperty(target, key, attribute);\\n  }\\n};\\n\\nlet obj = new Proxy(p, handler);\\nobj.a = 'A';\\n// set\\n// defineProperty\\n上面代码中，Proxy.set拦截里面使用了Reflect.set，而且传入了receiver，导致触发Proxy.defineProperty拦截。这是因为Proxy.set的receiver参数总是指向当前的 Proxy实例（即上例的obj），而Reflect.set一旦传入receiver，就会将属性赋值到receiver上面（即obj），导致触发defineProperty拦截。如果Reflect.set没有传入receiver，那么就不会触发defineProperty拦截。\\n\")])])]),r(\"h2\",{attrs:{id:\"reflect-deleteproperty-obj-name\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#reflect-deleteproperty-obj-name\"}},[e._v(\"#\")]),e._v(\" Reflect.deleteProperty(obj, name)\")]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v(\"\\nReflect.deleteProperty方法等同于delete obj[name]，用于删除对象的属性。\\n\\nconst myObj = { foo: 'bar' };\\n\\n// 旧写法\\ndelete myObj.foo;\\n\\n// 新写法\\nReflect.deleteProperty(myObj, 'foo');\\n该方法返回一个布尔值。如果删除成功，或者被删除的属性不存在，返回true；删除失败，被删除的属性依然存在，返回false。\\n\\n如果Reflect.deleteProperty()方法的第一个参数不是对象，会报错。\\n\")])])]),r(\"h2\",{attrs:{id:\"reflect-construct-target-args\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#reflect-construct-target-args\"}},[e._v(\"#\")]),e._v(\" Reflect.construct(target, args)\")]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v(\"\\nReflect.construct方法等同于new target(...args)，这提供了一种不使用new，来调用构造函数的方法。\\n\\nfunction Greeting(name) {\\n  this.name = name;\\n}\\n\\n// new 的写法\\nconst instance = new Greeting('张三');\\n\\n// Reflect.construct 的写法\\nconst instance = Reflect.construct(Greeting, ['张三']);\\n如果Reflect.construct()方法的第一个参数不是函数，会报错。\\n\")])])]),r(\"h2\",{attrs:{id:\"reflect-getprototypeof-obj\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#reflect-getprototypeof-obj\"}},[e._v(\"#\")]),e._v(\" Reflect.getPrototypeOf(obj)\")]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v(\"\\nReflect.getPrototypeOf方法用于读取对象的__proto__属性，对应Object.getPrototypeOf(obj)。\\n\\nconst myObj = new FancyThing();\\n\\n// 旧写法\\nObject.getPrototypeOf(myObj) === FancyThing.prototype;\\n\\n// 新写法\\nReflect.getPrototypeOf(myObj) === FancyThing.prototype;\\nReflect.getPrototypeOf和Object.getPrototypeOf的一个区别是，如果参数不是对象，Object.getPrototypeOf会将这个参数转为对象，然后再运行，而Reflect.getPrototypeOf会报错。\\n\\nObject.getPrototypeOf(1) // Number {[[PrimitiveValue]]: 0}\\nReflect.getPrototypeOf(1) // 报错\\n\")])])]),r(\"h2\",{attrs:{id:\"reflect-setprototypeof-obj-newproto\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#reflect-setprototypeof-obj-newproto\"}},[e._v(\"#\")]),e._v(\" Reflect.setPrototypeOf(obj, newProto)\")]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v(\"\\n\\nReflect.setPrototypeOf方法用于设置目标对象的原型（prototype），对应Object.setPrototypeOf(obj, newProto)方法。它返回一个布尔值，表示是否设置成功。\\n\\nconst myObj = {};\\n\\n// 旧写法\\nObject.setPrototypeOf(myObj, Array.prototype);\\n\\n// 新写法\\nReflect.setPrototypeOf(myObj, Array.prototype);\\n\\nmyObj.length // 0\\n如果无法设置目标对象的原型（比如，目标对象禁止扩展），Reflect.setPrototypeOf方法返回false。\\n\\nReflect.setPrototypeOf({}, null)\\n// true\\nReflect.setPrototypeOf(Object.freeze({}), null)\\n// false\\n如果第一个参数不是对象，Object.setPrototypeOf会返回第一个参数本身，而Reflect.setPrototypeOf会报错。\\n\\nObject.setPrototypeOf(1, {})\\n// 1\\n\\nReflect.setPrototypeOf(1, {})\\n// TypeError: Reflect.setPrototypeOf called on non-object\\n如果第一个参数是undefined或null，Object.setPrototypeOf和Reflect.setPrototypeOf都会报错。\\n\\nObject.setPrototypeOf(null, {})\\n// TypeError: Object.setPrototypeOf called on null or undefined\\n\\nReflect.setPrototypeOf(null, {})\\n// TypeError: Reflect.setPrototypeOf called on non-object\\n\")])])]),r(\"h2\",{attrs:{id:\"reflect-apply-func-thisarg-args\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#reflect-apply-func-thisarg-args\"}},[e._v(\"#\")]),e._v(\" Reflect.apply(func, thisArg, args)\")]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v(\"\\nReflect.apply方法等同于Function.prototype.apply.call(func, thisArg, args)，用于绑定this对象后执行给定函数。\\n\\n一般来说，如果要绑定一个函数的this对象，可以这样写fn.apply(obj, args)，但是如果函数定义了自己的apply方法，就只能写成Function.prototype.apply.call(fn, obj, args)，采用Reflect对象可以简化这种操作。\\n\\nconst ages = [11, 33, 12, 54, 18, 96];\\n\\n// 旧写法\\nconst youngest = Math.min.apply(Math, ages);\\nconst oldest = Math.max.apply(Math, ages);\\nconst type = Object.prototype.toString.call(youngest);\\n\\n// 新写法\\nconst youngest = Reflect.apply(Math.min, Math, ages);\\nconst oldest = Reflect.apply(Math.max, Math, ages);\\nconst type = Reflect.apply(Object.prototype.toString, youngest, []);\\n\")])])]),r(\"h2\",{attrs:{id:\"reflect-defineproperty-target-propertykey-attributes\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#reflect-defineproperty-target-propertykey-attributes\"}},[e._v(\"#\")]),e._v(\" Reflect.defineProperty(target, propertyKey, attributes)\")]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v(\"\\nReflect.defineProperty方法基本等同于Object.defineProperty，用来为对象定义属性。未来，后者会被逐渐废除，请从现在开始就使用Reflect.defineProperty代替它。\\n\\nfunction MyDate() {\\n  /*…*/\\n}\\n\\n// 旧写法\\nObject.defineProperty(MyDate, 'now', {\\n  value: () => Date.now()\\n});\\n\\n// 新写法\\nReflect.defineProperty(MyDate, 'now', {\\n  value: () => Date.now()\\n});\\n如果Reflect.defineProperty的第一个参数不是对象，就会抛出错误，比如Reflect.defineProperty(1, 'foo')。\\n\\n这个方法可以与Proxy.defineProperty配合使用。\\n\\nconst p = new Proxy({}, {\\n  defineProperty(target, prop, descriptor) {\\n    console.log(descriptor);\\n    return Reflect.defineProperty(target, prop, descriptor);\\n  }\\n});\\n\\np.foo = 'bar';\\n// {value: \\\"bar\\\", writable: true, enumerable: true, configurable: true}\\n\\np.foo // \\\"bar\\\"\\n上面代码中，Proxy.defineProperty对属性赋值设置了拦截，然后使用Reflect.defineProperty完成了赋值。\\n\")])])]),r(\"h2\",{attrs:{id:\"reflect-getownpropertydescriptor-target-propertykey\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#reflect-getownpropertydescriptor-target-propertykey\"}},[e._v(\"#\")]),e._v(\" Reflect.getOwnPropertyDescriptor(target, propertyKey)\")]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v(\"Reflect.getOwnPropertyDescriptor基本等同于Object.getOwnPropertyDescriptor，用于得到指定属性的描述对象，将来会替代掉后者。\\nReflect.getOwnPropertyDescriptor(target, propertyKey)\\nvar myObject = {};\\nObject.defineProperty(myObject, 'hidden', {\\n  value: true,\\n  enumerable: false,\\n});\\n\\n// 旧写法\\nvar theDescriptor = Object.getOwnPropertyDescriptor(myObject, 'hidden');\\n\\n// 新写法\\nvar theDescriptor = Reflect.getOwnPropertyDescriptor(myObject, 'hidden');\\nReflect.getOwnPropertyDescriptor和Object.getOwnPropertyDescriptor的一个区别是，如果第一个参数不是对象，Object.getOwnPropertyDescriptor(1, 'foo')不报错，返回undefined，而Reflect.getOwnPropertyDescriptor(1, 'foo')会抛出错误，表示参数非法。\\n\")])])]),r(\"h2\",{attrs:{id:\"reflect-isextensible-target\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#reflect-isextensible-target\"}},[e._v(\"#\")]),e._v(\" Reflect.isExtensible (target)\")]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v(\"\\nReflect.isExtensible方法对应Object.isExtensible，返回一个布尔值，表示当前对象是否可扩展。\\n\\nconst myObject = {};\\n\\n// 旧写法\\nObject.isExtensible(myObject) // true\\n\\n// 新写法\\nReflect.isExtensible(myObject) // true\\n如果参数不是对象，Object.isExtensible会返回false，因为非对象本来就是不可扩展的，而Reflect.isExtensible会报错。\\n\\nObject.isExtensible(1) // false\\nReflect.isExtensible(1) // 报错\\n\")])])]),r(\"h2\",{attrs:{id:\"reflect-preventextensions-target\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#reflect-preventextensions-target\"}},[e._v(\"#\")]),e._v(\" Reflect.preventExtensions(target)\")]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v(\"\\nReflect.preventExtensions对应Object.preventExtensions方法，用于让一个对象变为不可扩展。它返回一个布尔值，表示是否操作成功。\\n\\nvar myObject = {};\\n\\n// 旧写法\\nObject.preventExtensions(myObject) // Object {}\\n\\n// 新写法\\nReflect.preventExtensions(myObject) // true\\n如果参数不是对象，Object.preventExtensions在 ES5 环境报错，在 ES6 环境返回传入的参数，而Reflect.preventExtensions会报错。\\n\\n// ES5 环境\\nObject.preventExtensions(1) // 报错\\n\\n// ES6 环境\\nObject.preventExtensions(1) // 1\\n\\n// 新写法\\nReflect.preventExtensions(1) // 报错\\n\")])])]),r(\"h2\",{attrs:{id:\"reflect-ownkeys-target\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#reflect-ownkeys-target\"}},[e._v(\"#\")]),e._v(\" Reflect.ownKeys (target)\")]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v(\"\\nReflect.ownKeys方法用于返回对象的所有属性，基本等同于Object.getOwnPropertyNames与Object.getOwnPropertySymbols之和。\\n\\nvar myObject = {\\n  foo: 1,\\n  bar: 2,\\n  [Symbol.for('baz')]: 3,\\n  [Symbol.for('bing')]: 4,\\n};\\n\\n// 旧写法\\nObject.getOwnPropertyNames(myObject)\\n// ['foo', 'bar']\\n\\nObject.getOwnPropertySymbols(myObject)\\n//[Symbol(baz), Symbol(bing)]\\n\\n// 新写法\\nReflect.ownKeys(myObject)\\n// ['foo', 'bar', Symbol(baz), Symbol(bing)]\\n如果Reflect.ownKeys()方法的第一个参数不是对象，会报错。\\n\")])])])])}),[],!1,null,null,null);t.default=a.exports}}]);","extractedComments":[]}