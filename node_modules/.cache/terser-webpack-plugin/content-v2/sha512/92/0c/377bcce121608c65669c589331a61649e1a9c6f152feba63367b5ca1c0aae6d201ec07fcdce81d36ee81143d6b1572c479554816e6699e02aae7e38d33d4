{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{563:function(n,a,t){\"use strict\";t.r(a);var s=t(12),e=Object(s.a)({},(function(){var n=this,a=n.$createElement,t=n._self._c||a;return t(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":n.$parent.slotKey}},[t(\"h2\",{attrs:{id:\"按位与\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#按位与\"}},[n._v(\"#\")]),n._v(\" 按位与(&)\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v('&&运算符我们都知道，只有两个都为真，结果才为真。&道理是一样的，只有两个数的值为1时，才返回1。例如1和3的按位与操作：\\n\\n                    0001\\n                 &  0011\\n                ---------\\n                    0001\\n只有对应的数为1时，结果才为1，其他都为0。\\n\\n用一个数和1进行按位&操作来判断：\\n\\nfunction assert(n) {\\nif (n & 1) {\\n    console.log(\"n是奇数\");\\n} else {\\n    console.log(\"n是偶数\");\\n}\\n}\\n\\nassert(3); // \"n是奇数\"\\n下面是位运算过程：\\n\\n                 1 = 0001\\n                 3 = 0011\\n                 --------\\n                     & = 0001\\n奇数的二进制码的最后一位数肯定是1，而1只有最后一位为1，按位&操作之后，结果肯定只有最后一位数为1。而偶数的二进制表示的最后一位数是0，和1进行按位&操作，结果所有位数都为0。\\n')])])]),t(\"h2\",{attrs:{id:\"按位或\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#按位或\"}},[n._v(\"#\")]),n._v(\" 按位或(|)\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"|与||操作符的道理也是一样的，只要两个数中有一个数为1，结果就为1，其他则为0。\\n\\n                        0001\\n                 |  0011\\n                ---------\\n                    0011\\n对浮点数向下求整，我们会用下面的方法：\\n\\nvar num = Math.floor(1.1); // 1\\n我们也可以用位运算来求整：\\n\\nvar num = 1.1 | 0; // 1\\n其实浮点数是不支持位运算的，所以会先把1.1转成整数1再进行位运算，就好像是对浮点数向下求整。所以1|0的结果就是1。\\n\")])])]),t(\"h2\",{attrs:{id:\"按位非\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#按位非\"}},[n._v(\"#\")]),n._v(\" 按位非(~)\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"按位非就是求二进制的反码：\\n\\nvar num = 1; // 二进制 00000000000000000000000000000001\\nvar num1 = ~num; // 二进制 11111111111111111111111111111110\\n我们知道，js中的数字默认是有符号的。有符号的32位二进制的最高位也就是第一位数字代表着正负，1代表负数，0代表整数。那到底11111111111111111111111111111110等于多少呢？最高位为1代表负数，负数的二进制转化为十进制：符号位不变，其他位取反加1。取反之后为10000000000000000000000000000001，加1之后为10000000000000000000000000000010，十进制为-2。\\n\")])])]),t(\"h2\",{attrs:{id:\"按位异或\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#按位异或\"}},[n._v(\"#\")]),n._v(\" 按位异或(^)\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"按位异或是两个数中只有一个1时返回1，其他情况返回0。\\n\\n                        0001\\n                 ^  0011\\n                ---------\\n                    0010\\n数字与数字本身按位异或操作得到的是0，因为每两个对应的数字都相同，所以最后返回的都是0。\\n\\n我们经常会需要调换两个数字的值：\\n\\nvar num1 = 1, num2 = 2, temp;\\ntemp = num1;\\nnum1 = num2; // 2\\nnum2 = temp; // 1\\n如果装逼一点的话，可以这样：\\n\\nvar num1 = 1, num2 = 2;\\nnum1 = [num2, num2 = num1][0];\\nconsole.log(num1); // 2\\nconsole.log(num2); // 1\\n如果想再装的稳一点的话，可以这样：\\n\\nvar num1 = 1, num2 = 2;\\nnum1 ^= num2; // num1 = num1 ^ num2 = 1 ^ 2 = 3\\nnum2 ^= num1; // num2 = num2 ^ (num1 ^ num2) = 2 ^ (1 ^ 2) = 1\\nnum1 ^= num2; // num1 = num1 ^ num2 = 3 ^ 1 = 2\\nconsole.log(num1); // 2\\nconsole.log(num2); // 1\\n\")])])]),t(\"h2\",{attrs:{id:\"有符号左移\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#有符号左移\"}},[n._v(\"#\")]),n._v(\" 有符号左移(<<)\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"有符号左移会将32位二进制数的所有位向左移动指定位数。如：\\n\\nvar num = 2; // 二进制10\\nnum = num << 5; // 二进制1000000，十进制64\\n如果要求2的n次方，可以这样：\\n\\nfunction power(n) {\\n    return 1 << n;\\n}\\n\\npower(5); // 32\\n1的二进制是01，左移5位就是0100000，十进制就是2的5次方32。\\n\\n有符号右移(>>)\\n\\n有符号右移会将32位二进制数的所有位向右移动指定位数。如：\\n\\nvar num = 64; // 二进制1000000\\nnum = num >> 5; // 二进制10，十进制2\\n求一个数的二分之一：\\n\\nvar num = 64 >> 1; // 32\\n有符号左移与右移不会影响符号位。\\n\")])])]),t(\"h2\",{attrs:{id:\"无符号右移\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#无符号右移\"}},[n._v(\"#\")]),n._v(\" 无符号右移(>>>)\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"正数的无符号右移与有符号右移结果是一样的。负数的无符号右移会把符号位也一起移动，而且无符号右移会把负数的二进制码当成正数的二进制码：\\n\\nvar num = -64; // 11111111111111111111111111000000\\nnum = num >>> 5; // 134217726\\n所以，我们可以利用无符号右移来判断一个数的正负：\\n\\nfunction isPos(n) {\\nreturn (n === (n >>> 0)) ? true : false;    \\n}\\n\\nisPos(-1); // false\\nisPos(1); // true\\n-1>>>0虽然没有向右移动位数，但-1的二进制码已经变成了正数的二进制码：\\n\\n11111111111111111111111111111111 \\n所以-1>>>0的值为4294967295。\\n\\n~~用来取整\\n\\n~~3.5    3\\n\\n~~-2.6   -2\\n\")])])]),t(\"h1\",{attrs:{id:\"高性能-javascript-之位运算\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#高性能-javascript-之位运算\"}},[n._v(\"#\")]),n._v(\" \"),t(\"a\",{attrs:{href:\"https://www.jianshu.com/p/cc7018492c0f\",target:\"_blank\",rel:\"noopener noreferrer\"}},[n._v(\"高性能 JavaScript 之位运算\"),t(\"OutboundLink\")],1)]),n._v(\" \"),t(\"h3\",{attrs:{id:\"一-代替数学运算\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#一-代替数学运算\"}},[n._v(\"#\")]),n._v(\" (一) 代替数学运算\")]),n._v(\" \"),t(\"p\",[n._v(\"很多情况下，我们可以使用位运算替代数学运算操作，比如判断一个数是否是奇数，最典型的做法当然是对 2 求余数，也即 if (value % 2) {}。但与此同时，二进制奇数的最低位一定是 1，这样我们就能通过如按位与的方式完成我们的需求，if (value & 1) {}。虽然改动比较小，但这个计算速度却将因此得到很大的提高。\")]),n._v(\" \"),t(\"h3\",{attrs:{id:\"二-位掩码\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#二-位掩码\"}},[n._v(\"#\")]),n._v(\" (二) 位掩码\")]),n._v(\" \"),t(\"p\",[n._v(\"位掩码在一些偏底层的语言中使用得非常广泛，但 JavaScript 中却似乎被大众给忽略了，更多的情况下，大家都在关注业务、功能和兼容性等方面的问题，运行环境中提供的便利的 api 似乎也让我们觉得没太大必要使用掩码技术，但性能要求较高的场景中，我们还是会尝试从一些经典的编程范式中寻找答案。用一个很简单的例子来说明位掩码技术：\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"// 定义所有的可选项\\nvar OPTION_A = 1,\\n    OPTION_B = 2,\\n    OPTION_C = 4,\\n    OPTION_D = 8,\\n    OPTION_E = 16;\\n\\n// 包含选项 A、B、D\\nvar options = OPTION_A | OPTION_B | OPTION_D;      // 1 | 10 | 1000 -> 1011\\n\\n// 判断选项是否被包含在 options 中\\noptions & OPTION_A        // 1011 & 1 -> 0001, true\\noptions & OPTION_B        // 1011 & 10 ->  0010, true\\noptions & OPTION_C        // 1011 & 110 -> 0, false\\noptions & OPTION_D        // 1011 & 1000 -> 1000, true\\noptions & OPTION_E        // 1011 & 10000 -> 0, false\\n\")])])]),t(\"p\",[n._v(\"之前，你可能会使用比如数组的 indexOf 或者 Map 数据结构等方式来确认一个数据在不在你的数据集合中，但相比而言，掩码的运算速度远比它们高，除却函数调用带来额外开销，位运算发生于系统底层，尤其是如果有多个选项保存在一起并需要频繁检查的时候，位掩码将大放异彩。\")])])}),[],!1,null,null,null);a.default=e.exports}}]);","extractedComments":[]}