{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[111],{652:function(e,a,t){\"use strict\";t.r(a);var n=t(12),i=Object(n.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":e.$parent.slotKey}},[t(\"h1\",{attrs:{id:\"jsbridge\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#jsbridge\"}},[e._v(\"#\")]),e._v(\" jsbridge\")]),e._v(\" \"),t(\"p\",[e._v(\"https://mp.weixin.qq.com/s/cBsmunLXLBEtR14cFfy1LQ\")]),e._v(\" \"),t(\"p\",[e._v(\"h5 和 原生app 交互原理\\nhttps://mp.weixin.qq.com/s/oMTqMqZHAP3OSeysb1Efcg\")]),e._v(\" \"),t(\"p\",[e._v(\"https://mp.weixin.qq.com/s/1O8xawgwDSA-nClRH0d_2Q\\nhttps://segmentfault.com/a/1190000021915545\")]),e._v(\" \"),t(\"h4\",{attrs:{id:\"url-scheme\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#url-scheme\"}},[e._v(\"#\")]),e._v(\" Url scheme\")]),e._v(\" \"),t(\"p\",[e._v(\"你可以在浏览器里面直接输入 \"),t(\"code\",[e._v(\"weixin://\")]),e._v(\"，系统就会提示你是否要打开微信。输入 \"),t(\"code\",[e._v(\"mqq://\")]),e._v(\" 就会帮你唤起手机 QQ。\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"URI = scheme:[//authority]path[?query][#fragment]\\n// scheme     = http\\n// authority  = www.baidu.com\\n// path       = /link\\n// query      = url=xxxxx\\nauthority = [userinfo@]host[:port]\\n\")])])]),t(\"p\",[e._v(\"Android 里面需要到 AndroidManifest.xml 文件中去注册 Scheme\")]),e._v(\" \"),t(\"p\",[e._v(\"在 iOS 中需要在 Xcode 里面注册，有一些已经是系统使用的不应该使用，比如 Maps、YouTube、Music。\")]),e._v(\" \"),t(\"p\",[e._v(\"具体可以参考苹果开发者官网文档：Defining a Custom URL Scheme for Your App\")]),e._v(\" \"),t(\"h4\",{attrs:{id:\"js-调用native\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#js-调用native\"}},[e._v(\"#\")]),e._v(\" Js 调用Native\")]),e._v(\" \"),t(\"p\",[e._v(\"iOS 里面又需要区分 UIWebView 和 WKWebView 两种 WebView：WKWebView 是 iOS8 之后出现的，目的是取代笨重的 UIWebView，它占用内存更少，大概是 UIWebView 的 1/3，支持更好的 HTML5 特性，性能更加强大。\")]),e._v(\" \"),t(\"p\",[e._v(\"但也有一些缺点，比如不支持缓存，需要自己注入 Cookie，发送 POST 请求的时候带不了参数，拦截 POST 请求的时候无法解析参数等等。\")]),e._v(\" \"),t(\"h4\",{attrs:{id:\"js-调用-native-通信大致有三种方法\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#js-调用-native-通信大致有三种方法\"}},[e._v(\"#\")]),e._v(\" JS 调用 Native 通信大致有三种方法：\")]),e._v(\" \"),t(\"ol\",[t(\"li\",[e._v(\"拦截 Scheme\")]),e._v(\" \"),t(\"li\",[e._v(\"弹窗拦截\")]),e._v(\" \"),t(\"li\",[e._v(\"注入 JS 上下文\")])]),e._v(\" \"),t(\"h5\",{attrs:{id:\"拦截-scheme\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#拦截-scheme\"}},[e._v(\"#\")]),e._v(\" 拦截 Scheme\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"\\n\\naxios.get('http://xxxx?func=scan&callback_id=yyyy')\\n客户端可以拦截这个请求，去解析参数上面的 func 来判断当前需要调起哪个功能。客户端调起扫码功能之后，会获取 WebView 上面的 callbacks 对象，根据 callback_id 回调它。\\n\\n所以基于上面的例子，我们可以把域名和路径当做通信标识，参数里面的 func 当做指令，callback_id 当做回调函数，其他参数当做数据传递。对于不满足条件的 http 请求不应该拦截。\\n\\n当然了，现在主流的方式是前面我们看到的自定义 Scheme 协议，以这个为通信标识，域名和路径当做指令。\\n\\n这种方式的好处就是 iOS6 以前只支持这种方式，兼容性比较好。\\n\")])])]),t(\"h5\",{attrs:{id:\"js-端\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#js-端\"}},[e._v(\"#\")]),e._v(\" js 端\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v('\\n\\n使用 a 标签跳转\\n<a href=\"taobao://\">点击我打开淘宝</a>\\n\\n重定向\\nlocation.href = \"taobao://\"\\n\\niframe 跳转\\nconst iframe = document.createElement(\"iframe\");\\niframe.src = \"taobao://\"\\niframe.style.display = \"none\"\\ndocument.body.appendChild(iframe)\\n\\nAndroid 端\\n\\n在 Android 侧可以用 shouldOverrideUrlLoading 来拦截 url 请求。\\n\\n@Override\\npublic boolean shouldOverrideUrlLoading(WebView view, String url) {\\n    if (url.startsWith(\"taobao\")) {\\n        // 拿到调用路径后解析调用的指令和参数，根据这些去调用 Native 方法\\n        return true;\\n    }\\n}\\n\\n\\n在 iOS 侧需要区分 UIWebView 和 WKWebView 两种方式。\\n\\n在 UIWebView 中：\\n\\n- (BOOL)shouldStartLoadWithRequest:(NSURLRequest *)request\\n                    navigationType:(BPWebViewNavigationType)navigationType\\n{\\n\\n    if (xxx) {\\n        // 拿到调用路径后解析调用的指令和参数，根据这些去调用 Native 方法\\n        return NO;\\n    }\\n\\n    return [super shouldStartLoadWithRequest:request navigationType:navigationType];\\n}\\n\\n\\n在 WKWebView 中：\\n\\n- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(nonnull WKNavigationAction *)navigationAction decisionHandler:(nonnull void (^)(WKNavigationActionPolicy))decisionHandler\\n{\\n    if(xxx) {\\n        // 拿到调用路径后解析调用的指令和参数，根据这些去调用 Native 方法\\n        BLOCK_EXEC(decisionHandler, WKNavigationActionPolicyCancel);\\n    } else {\\n        BLOCK_EXEC(decisionHandler, WKNavigationActionPolicyAllow);\\n    }\\n\\n    [self.webView.URLLoader webView:webView decidedPolicy:policy forNavigationAction:navigationAction];\\n}\\n')])])]),t(\"p\",[e._v(\"目前不建议只使用拦截 URL Scheme 解析参数的形式，主要存在几个问题。\")]),e._v(\" \"),t(\"ol\",[t(\"li\",[e._v(\"连续续调用 \"),t(\"code\",[e._v(\"location.href\")]),e._v(\" 会出现消息丢失，因为 WebView 限制了连续跳转，会过滤掉后续的请求。\")]),e._v(\" \"),t(\"li\",[e._v(\"URL 会有长度限制，一旦过长就会出现信息丢失 因此，类似 WebViewJavaScriptBridge 这类库，就结合了注入 API 的形式一起使用，这也是我们这边目前使用的方式，后面会介绍一下。\")])]),e._v(\" \"),t(\"h5\",{attrs:{id:\"弹窗拦截\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#弹窗拦截\"}},[e._v(\"#\")]),e._v(\" 弹窗拦截\")]),e._v(\" \"),t(\"p\",[e._v(\"安卓实现\")]),e._v(\" \"),t(\"p\",[e._v(\"这种方式是利用弹窗会触发 WebView 相应事件来拦截的。\")]),e._v(\" \"),t(\"p\",[e._v(\"一般是在 \"),t(\"code\",[e._v(\"setWebChromeClient\")]),e._v(\" 里面的 \"),t(\"code\",[e._v(\"onJsAlert\")]),e._v(\"、\"),t(\"code\",[e._v(\"onJsConfirm\")]),e._v(\"、\"),t(\"code\",[e._v(\"onJsPrompt\")]),e._v(\" 方法拦截并解析他们传来的消息。\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"// 拦截 Prompt\\n@Override\\npublic boolean onJsPrompt(WebView view, String url, String message, String defaultValue, JsPromptResult result) {\\n       if (xxx) {\\n        // 解析 message 的值，调用对应方法\\n       }\\n       return super.onJsPrompt(view, url, message, defaultValue, result);\\n   }\\n// 拦截 Confirm\\n@Override\\npublic boolean onJsConfirm(WebView view, String url, String message, JsResult result) {\\n       return super.onJsConfirm(view, url, message, result);\\n   }\\n// 拦截 Alert\\n@Override\\npublic boolean onJsAlert(WebView view, String url, String message, JsResult result) {\\n       return super.onJsAlert(view, url, message, result);\\n   }\\n\")])])]),t(\"p\",[e._v(\"ios 实现\")]),e._v(\" \"),t(\"p\",[e._v(\"我们以 WKWebView 为例：\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v('+ (void)webViewRunJavaScriptTextInputPanelWithPrompt:(NSString *)prompt\\n    defaultText:(NSString *)defaultText\\n    completionHandler:(void (^)(NSString * _Nullable))completionHandler\\n{\\n    /** Triggered by JS:\\n    var person = prompt(\"Please enter your name\", \"Harry Potter\");\\n    if (person == null || person == \"\") {\\n       txt = \"User cancelled the prompt.\";\\n    } else {\\n       txt = \"Hello \" + person + \"! How are you today?\";\\n    }\\n    */\\n    if (xxx) {\\n        BLOCK_EXEC(completionHandler, text);\\n    } else {\\n        BLOCK_EXEC(completionHandler, nil);\\n    }\\n }\\n\\n')])])]),t(\"p\",[e._v(\"这种方式的缺点就是在 iOS 上面 UIWebView 不支持，虽然 WKWebView 支持，但它又有更好的 \"),t(\"code\",[e._v(\"scriptMessageHandler\")]),e._v(\"，比较尴尬。\")]),e._v(\" \"),t(\"h5\",{attrs:{id:\"注入上下文\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#注入上下文\"}},[e._v(\"#\")]),e._v(\" 注入上下文\")]),e._v(\" \"),t(\"p\",[e._v(\"前面我们有讲过在 iOS 中内置了 JavaScriptCore 这个框架，可以实现执行 JS 以及注入 Native 对象等功能。\")]),e._v(\" \"),t(\"p\",[e._v(\"这种方式不依赖拦截，主要是通过 WebView 向 JS 的上下文注入对象和方法，可以让 JS 直接调用原生。\")]),e._v(\" \"),t(\"p\",[e._v(\"PS：iOS 中的 Block 是 OC 对于闭包的实现，它本质上是个对象，定义 JS 里面的函数。\")]),e._v(\" \"),t(\"p\",[e._v(\"ios uiwebview\")]),e._v(\" \"),t(\"p\",[e._v(\"iOS 侧代码：\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v('\\n// 获取 JS 上下文\\nJSContext *context = [webview valueForKeyPath:@\"documentView.webView.mainFrame.javaScriptContext\"];\\n// 注入 Block\\ncontext[@\"callHandler\"] = ^(JSValue * data) {\\n    // 处理调用方法和参数\\n    // 调用 Native 功能\\n    // 回调 JS Callback\\n}\\n')])])]),t(\"p\",[e._v(\"js代码\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v('window.callHandler(JSON.stringify({\\n    type: \"scan\",\\n    data: \"\",\\n    callback: function(data) {\\n    }\\n}));\\n')])])]),t(\"p\",[e._v(\"这种方式的牛逼之处在于，JS 调用是同步的，可以立马拿到返回值。\")]),e._v(\" \"),t(\"p\",[e._v(\"我们也不再需要像拦截方式一样，每次传值都要把对象做 \"),t(\"code\",[e._v(\"JSON.stringify\")]),e._v(\"，可以直接传 JSON 过去，也支持直接传一个函数过去。\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"iOS WKWebView\\n\\nWKWebView 里面通过 addScriptMessageHandler 来注入对象到 JS 上下文，可以在 WebView 销毁的时候调用 removeScriptMessageHandler 来销毁这个对象。\\n\\n前端调用注入的原生方法之后，可以通过 didReceiveScriptMessage 来接收前端传过来的参数。\\n\")])])]),t(\"h4\",{attrs:{id:\"native-调用-js\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#native-调用-js\"}},[e._v(\"#\")]),e._v(\" Native 调用 JS\")]),e._v(\" \"),t(\"p\",[e._v(\"Native 调用 JS 一般就是直接 JS 代码字符串，有些类似我们调用 JS 中的 \"),t(\"code\",[e._v(\"eval\")]),e._v(\" 去执行一串代码。一般有 \"),t(\"code\",[e._v(\"loadUrl\")]),e._v(\"、\"),t(\"code\",[e._v(\"evaluateJavascript\")]),e._v(\" 等几种方法，这里逐一介绍。\")]),e._v(\" \"),t(\"p\",[e._v(\"但是不管哪种方式，客户端都只能拿到挂载到 \"),t(\"code\",[e._v(\"window\")]),e._v(\" 对象上面的属性和方法。\")]),e._v(\" \"),t(\"p\",[e._v(\"安卓调用方式\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v('if (Build.VERSION.SDK_INT > 19) //see what wrapper we have\\n{\\n    webView.evaluateJavascript(\"javascript:foo()\", null);\\n} else {\\n    webView.loadUrl(\"javascript:foo()\");\\n}\\n')])])]),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v('UIWebView\\n\\n在 iOS 的 UIWebView 里面使用 stringByEvaluatingJavaScriptFromString 来调用 JS 代码。这种方式是同步的，会阻塞线程。\\n\\nresults = [self.webView stringByEvaluatingJavaScriptFromString:\"foo()\"];\\n')])])]),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v('WKWebView\\n\\nWKWebView 可以使用 evaluateJavaScript 方法来调用 JS 代码。\\n\\n[self.webView evaluateJavaScript:@\"document.body.offsetHeight;\" completionHandler:^(id _Nullable response, NSError * _Nullable error) {\\n    // 获取返回值 response\\n    }];\\n')])])]),t(\"h4\",{attrs:{id:\"js-bridge-设计\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#js-bridge-设计\"}},[e._v(\"#\")]),e._v(\" JS Bridge 设计\")]),e._v(\" \"),t(\"p\",[e._v(\"前面讲完了 JS 和 Native 互调的所有方法，这里来介绍一下我们这边 JS Bridge 的设计吧。\")]),e._v(\" \"),t(\"p\",[e._v(\"我们这边的 JS Bridge 通信是基于 WebViewJavascriptBridge 这个库来实现的。\")]),e._v(\" \"),t(\"p\",[e._v(\"主要是结合 Scheme 协议+上下文注入来做。考虑到 Android 和 iOS 不一样的通信方式，这里进行了封装，保证提供给外部的 API 一致。\")]),e._v(\" \"),t(\"p\",[e._v(\"具体功能的调用我们封装成了 npm 包，下面的是几个基础 API：\")]),e._v(\" \"),t(\"ol\",[t(\"li\",[e._v(\"callHandler(name, params, callback)：这个是调用 Native 功能的方法，传模块名、参数、回调函数给 Native。\")]),e._v(\" \"),t(\"li\",[e._v(\"hasHandler(name)：这个是检查客户端是否支持某个功能的调用。\")]),e._v(\" \"),t(\"li\",[e._v(\"registerHandler(name)：这个是提前注册一个函数，等待 Native 回调，比如 \"),t(\"code\",[e._v(\"pageDidBack\")]),e._v(\" 这种场景。\")])])])}),[],!1,null,null,null);a.default=i.exports}}]);","extractedComments":[]}