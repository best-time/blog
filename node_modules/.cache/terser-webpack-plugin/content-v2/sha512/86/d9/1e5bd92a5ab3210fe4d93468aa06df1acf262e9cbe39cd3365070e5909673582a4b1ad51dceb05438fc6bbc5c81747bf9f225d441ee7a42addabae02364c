{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[416],{957:function(n,a,r){\"use strict\";r.r(a);var i=r(12),e=Object(i.a)({},(function(){var n=this,a=n.$createElement,r=n._self._c||a;return r(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":n.$parent.slotKey}},[r(\"p\",[n._v(\"桶排序\")]),n._v(\" \"),r(\"p\",[n._v(\"桶排序会经历三次遍历：准备一个数组、遍历一遍数组、重构一遍数组，是非基于比较的排序，下面以一个问题来阐述其思路。\\n问题：\\n给定一个数组，求如果排序之后，相邻两个数的最大差值，要求时间复杂度O(N),且要求不能用基于比较的排序\")]),n._v(\" \"),r(\"p\",[n._v(\"思路：\\n1.准备桶：数组中有N个数就准备N+1个桶\\n2.遍历一遍数组，找到最大值max和最小值min\\n。若min = max，则差值=0；若min≠max，则最小值放在0号桶，最大值放在N号桶，剩下的数属于哪个范围就进哪个桶\\n3.根据鸽笼原理，则肯定有一个桶为空桶，设计该桶的目的是为了否定最大值在一个桶中，则最大差值的两个数一定来自于两个桶，但空桶两侧并不一定是最大值\\n4.所以只记录所有进入该桶的最小值min和最大值max和一个布尔值表示该桶有没有值\\n5.然后遍历这个数组，如果桶是空的，则跳到下一个数，如果桶非空，则找前一个非空桶，则最大差值=当前桶min - 上一个非空桶max，用全局变量更新最大值\\n时间复杂度：O(N)\\n空间复杂度：O(N)\")]),n._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[n._v(\"\\n\\nfunction maxGap(arr) {\\n    if(arr == null || arr.length <= 0) {\\n        return 0;\\n    }\\n    var len = arr.length;\\n    var max = -Infinity, min = Infinity;\\n    //遍历一遍数组,找到最大值max和最小值min\\n    for(var i = 0; i < len; i++) {\\n        max = max > arr[i] ? max : arr[i];\\n        min = min > arr[i] ? arr[i] : min;\\n    }\\n\\n    //若min = max,则差值为0;\\n    if(min == max) {\\n        return 0;\\n    }\\n\\n    var hasNum = new Array(len + 1);\\n    var mins = new Array(len + 1);\\n    var maxs = new Array(len + 1);\\n\\n    var bid = 0;//指定桶的编号\\n\\n    for(var i = 0; i < len; i++) {\\n        bid = bucket(arr[i], min, max, len);//获得该值是在哪个桶//由于有N+1个桶，所以间隔就是N个，所以此处除以的是len，然后通过这个函数得到应该放到哪个桶里\\n        maxs[bid] = hasNum[bid] ? Math.max(arr[i], maxs[bid]) : arr[i];\\n        mins[bid] = hasNum[bid] ? Math.min(arr[i], mins[bid]) : arr[i];\\n        hasNum[bid] = true;\\n    }\\n\\n    var res = 0;\\n    var lastMax = maxs[0];\\n\\n    for(var i = 0; i < len + 1; i++) {\\n        if(hasNum[i]) {\\n            res = Math.max(mins[i] - lastMax, res);\\n            lastMax = maxs[i];\\n        }\\n    }\\n    return res;\\n}\\n\\n//获得桶号\\n//这个函数用于判断在哪个桶中，参数分别为值、最小值、最大值、桶间隔\\nfunction bucket(value, min, max, len) {\\n    return parseInt((value - min) / ((max - min) / len));\\n}\\n\\n\")])])])])}),[],!1,null,null,null);a.default=e.exports}}]);","extractedComments":[]}