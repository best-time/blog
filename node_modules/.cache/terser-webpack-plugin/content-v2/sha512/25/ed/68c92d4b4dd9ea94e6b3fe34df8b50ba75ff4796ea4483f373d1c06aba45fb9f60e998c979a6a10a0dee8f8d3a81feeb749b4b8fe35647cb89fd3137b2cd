{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[102],{643:function(e,n,a){\"use strict\";a.r(n);var t=a(12),r=Object(t.a)({},(function(){var e=this,n=e.$createElement,a=e._self._c||n;return a(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":e.$parent.slotKey}},[a(\"h1\",{attrs:{id:\"tree-shaking\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#tree-shaking\"}},[e._v(\"#\")]),e._v(\" tree shaking\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"Tree shaking 是一种通过清除多余代码方式来优化项目打包体积的技术，\\n专业术语叫Dead code elimination\\n\")])])]),a(\"h2\",{attrs:{id:\"如何工作\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#如何工作\"}},[e._v(\"#\")]),e._v(\" 如何工作\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v('虽然tree shaking的概念在1990就提出了，但知道ES6的ES6-style模块出现后才真正被利用起来。这是因为tree shaking只能在静态modules下工作。ECMAScript 6 模块加载是静态的,因此整个依赖树可以被静态地推导出解析语法树。所以在ES6中使用tree shaking是非常容易的。而且，tree shaking不仅支持import/export级别，而且也支持statement(声明)级别。\\n\\n在ES6以前，我们可以使用CommonJS引入模块：require()，这种引入是动态的，也意味着我们可以基于条件来导入需要的代码：\\n\\nlet dynamicModule;\\n// 动态导入\\nif(condition) {\\n    myDynamicModule = require(\"foo\");\\n} else {\\n    myDynamicModule = require(\"bar\");\\n}\\nCommonJS的动态特性模块意味着tree shaking不适用。因为它是不可能确定哪些模块实际运行之前是需要的或者是不需要的。在ES6中，进入了完全静态的导入语法：import。这也意味着下面的导入是不可行的：\\n\\n// 不可行，ES6 的import是完全静态的\\nif(condition) {\\n    myDynamicModule = require(\"foo\");\\n} else {\\n    myDynamicModule = require(\"bar\");\\n}\\n我们只能通过导入所有的包后再进行条件获取。如下：\\n\\nimport foo from \"foo\";\\nimport bar from \"bar\";\\n\\nif(condition) {\\n    // foo.xxxx\\n} else {\\n    // bar.xxx\\n}\\nES6的import语法完美可以使用tree shaking，因为可以在代码不运行的情况下就能分析出不需要的代码。\\n')])])]),a(\"h2\",{attrs:{id:\"使用-tree-shaking\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#使用-tree-shaking\"}},[e._v(\"#\")]),e._v(\" 使用 Tree shaking\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"从webpack 2开始支持实现了Tree shaking特性，webpack 2正式版本内置支持ES2015 模块（也叫做harmony模块）和未引用模块检测能力。新的webpack 4 正式版本，扩展了这个检测能力，通过package.json的 sideEffects属性作为标记，向compiler 提供提示，表明项目中的哪些文件是 “pure(纯的 ES2015 模块)”，由此可以安全地删除文件中未使用的部分。\\n\\n本项目中使用的是webpack4,只需要将mode设置为production即可开启tree shaking\\n\\nentry: './src/index.js',\\nmode: 'production', // 设置为production模式\\noutput: {\\n\\tpath: path.resolve(__dirname, 'dist'),\\n\\tfilename: 'bundle.js'\\n},\\n如果是使用webpack2,可能你会发现tree shaking不起作用。因为babel会将代码编译成CommonJs模块，而tree shaking不支持CommonJs。所以需要配置不转义：\\n\\noptions: { presets: [ [ 'es2015', { modules: false } ] ] }\\n\\n\")])])]),a(\"h2\",{attrs:{id:\"副作用\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#副作用\"}},[e._v(\"#\")]),e._v(\" 副作用\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v('side effects是指那些当import的时候会执行一些动作，但是不一定会有任何export。比如ployfill,ployfills不对外暴露方法给主程序使用。\\n\\ntree shaking 不能自动的识别哪些代码属于side effects，因此手动指定这些代码显得非常重要，如果不指定可能会出现一些意想不到的问题。\\n\\n在webapck中，是通过package.json的sideEffects属性来实现的。\\n\\n{\\n  \"name\": \"tree-shaking\",\\n  \"sideEffects\": false\\n}\\n如果所有代码都不包含副作用，我们就可以简单地将该属性标记为false，来告知 webpack，它可以安全地删除未用到的export导出。\\n\\n如果你的代码确实有一些副作用，那么可以改为提供一个数组：\\n\\n{\\n  \"name\": \"tree-shaking\",\\n  \"sideEffects\": [\\n    \"./src/common/polyfill.js\"\\n  ]\\n}\\n总结\\ntree shaking 不支持动态导入（如CommonJS的require()语法），只支持纯静态的导入（ES6的import/export）\\nwebpack中可以在项目package.json文件中，添加一个 “sideEffects” 属性,手动指定由副作用的脚本\\n')])])]),a(\"h2\",{attrs:{id:\"在-webpack-中启动-tree-shaking\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#在-webpack-中启动-tree-shaking\"}},[e._v(\"#\")]),e._v(\" 在 Webpack 中启动 Tree Shaking\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"\\n在 Webpack 中，启动 Tree Shaking 功能必须同时满足三个条件：\\n\\n使用 ESM 规范编写模块代码\\n配置 optimization.usedExports 为 true，启动标记功能\\n启动代码优化功能，可以通过如下方式实现：\\n配置 mode = production\\n配置 optimization.minimize = true\\n提供 optimization.minimizer 数组\\n\")])])]),a(\"h2\",{attrs:{id:\"理论基础\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#理论基础\"}},[e._v(\"#\")]),e._v(\" 理论基础\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"在 CommonJs、AMD、CMD 等旧版本的 JavaScript 模块化方案中，导入导出行为是高度动态，难以预测的，例如：\\n\\nif(process.env.NODE_ENV === 'development'){\\n  require('./bar');\\n  exports.foo = 'foo';\\n}\\n而 ESM 方案则从规范层面规避这一行为，它要求所有的导入导出语句只能出现在模块顶层，且导入导出的模块名必须为字符串常量，这意味着下述代码在 ESM 方案下是非法的：\\n\\nif(process.env.NODE_ENV === 'development'){\\n  import bar from 'bar';\\n  export const foo = 'foo';\\n}\\n所以，ESM 下模块之间的依赖关系是高度确定的，与运行状态无关，编译工具只需要对 ESM 模块做静态分析，就可以从代码字面量中推断出哪些模块值未曾被其它模块使用，这是实现 Tree Shaking 技术的必要条件。\\n\")])])]),a(\"h2\",{attrs:{id:\"实现原理\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#实现原理\"}},[e._v(\"#\")]),e._v(\" 实现原理\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"Webpack 中，Tree-shaking 的实现一是先「标记」出模块导出值中哪些没有被用过，二是使用 Terser 删掉这些没被用到的导出语句。标记过程大致可划分为三个步骤：\\n\\nMake 阶段，收集模块导出变量并记录到模块依赖关系图 ModuleGraph 变量中\\nSeal 阶段，遍历 ModuleGraph 标记模块导出变量有没有被使用\\n生成产物时，若变量没有被其它模块使用则删除对应的导出语句\\n❝ 标记功能需要配置 optimization.usedExports = true 开启\\n❞\\n也就是说，标记的效果就是删除没有被其它模块使用的导出语句\\n\\n示例中，bar.js 模块(左二)导出了两个变量：bar 与 foo，其中 foo 没有被其它模块用到，所以经过标记后，构建产物(右一)中 foo 变量对应的导出语句就被删除了。作为对比，如果没有启动标记功能(optimization.usedExports = false 时)，则变量无论有没有被用到都会保留导出语句，如上图右二的产物代码所示。\\n\\n注意，这个时候 foo 变量对应的代码 const foo='foo' 都还保留完整，这是因为标记功能只会影响到模块的导出语句，真正执行“「Shaking」”操作的是 Terser 插件。例如在上例中 foo 变量经过标记后，已经变成一段 Dead Code —— 不可能被执行到的代码，这个时候只需要用 Terser 提供的 DCE 功能就可以删除这一段定义语句，以此实现完整的 Tree Shaking 效果。\\n\")])])]),a(\"h2\",{attrs:{id:\"收集模块导出\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#收集模块导出\"}},[e._v(\"#\")]),e._v(\" 收集模块导出\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"首先，Webpack 需要弄清楚每个模块分别有什么导出值，这一过程发生在 make 阶段，大体流程：\\n\\n❝ 关于 Make 阶段的更多说明，请参考前文 [万字总结] 一文吃透 Webpack 核心原理 。\\n❞\\n将模块的所有 ESM 导出语句转换为 Dependency 对象，并记录到 module 对象的 dependencies 集合，转换规则：\\n具名导出转换为 HarmonyExportSpecifierDependency 对象\\ndefault 导出转换为 HarmonyExportExpressionDependency 对象\\n例如对于下面的模块：\\n\\nexport const bar = 'bar';\\nexport const foo = 'foo';\\n\\nexport default 'foo-bar'\\n对应的dependencies 值为：\\n所有模块都编译完毕后，触发 compilation.hooks.finishModules 钩子，开始执行 FlagDependencyExportsPlugin 插件回调\\nFlagDependencyExportsPlugin 插件从 entry 开始读取 ModuleGraph 中存储的模块信息，遍历所有 module 对象\\n遍历 module 对象的 dependencies 数组，找到所有 HarmonyExportXXXDependency 类型的依赖对象，将其转换为 ExportInfo 对象并记录到 ModuleGraph 体系中\\n经过 FlagDependencyExportsPlugin 插件处理后，所有 ESM 风格的 export 语句都会记录在 ModuleGraph 体系内，后续操作就可以从 ModuleGraph 中直接读取出模块的导出值\\n\\n\")])])]),a(\"h2\",{attrs:{id:\"标记模块导出\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#标记模块导出\"}},[e._v(\"#\")]),e._v(\" 标记模块导出\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"模块导出信息收集完毕后，Webpack 需要标记出各个模块的导出列表中，哪些导出值有被其它模块用到，哪些没有，这一过程发生在 Seal 阶段，主流程：\\n\\n触发 compilation.hooks.optimizeDependencies 钩子，开始执行 FlagDependencyUsagePlugin 插件逻辑\\n在 FlagDependencyUsagePlugin 插件中，从 entry 开始逐步遍历 ModuleGraph 存储的所有 module 对象\\n遍历 module 对象对应的 exportInfo 数组\\n为每一个 exportInfo 对象执行 compilation.getDependencyReferencedExports 方法，确定其对应的 dependency 对象有否被其它模块使用\\n被任意模块使用到的导出值，调用 exportInfo.setUsedConditionally 方法将其标记为已被使用。\\nexportInfo.setUsedConditionally 内部修改 exportInfo._usedInRuntime 属性，记录该导出被如何使用\\n结束\\n上面是极度简化过的版本，中间还存在非常多的分支逻辑与复杂的集合操作，我们抓住重点：标记模块导出这一操作集中在 FlagDependencyUsagePlugin 插件中，执行结果最终会记录在模块导出语句对应的 exportInfo._usedInRuntime 字典中。\\n\")])])]),a(\"h2\",{attrs:{id:\"生成代码\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#生成代码\"}},[e._v(\"#\")]),e._v(\" 生成代码\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v('\\n经过前面的收集与标记步骤后，Webpack 已经在 ModuleGraph 体系中清楚地记录了每个模块都导出了哪些值，每个导出值又没那块模块所使用。接下来，Webpack 会根据导出值的使用情况生成不同的代码，例如：\\n\\n\\n重点关注 bar.js 文件，同样是导出值，bar 被 index.js 模块使用因此对应生成了 __webpack_require__.d 调用 \"bar\": ()=>(/* binding */ bar)，作为对比 foo 则仅仅保留了定义语句，没有在 chunk 中生成对应的 export。\\n\\n❝ 关于 Webpack 产物的内容及 __webpack_require__.d 方法的含义，可参考 Webpack 原理系列六： 彻底理解 Webpack 运行时 一文。\\n❞\\n这一段生成逻辑均由导出语句对应的 HarmonyExportXXXDependency 类实现，大体的流程：\\n\\n打包阶段，调用 HarmonyExportXXXDependency.Template.apply 方法生成代码\\n在 apply 方法内，读取 ModuleGraph 中存储的 exportsInfo 信息，判断哪些导出值被使用，哪些未被使用\\n对已经被使用及未被使用的导出值，分别创建对应的 HarmonyExportInitFragment 对象，保存到 initFragments 数组\\n遍历 initFragments 数组，生成最终结果\\n基本上，这一步的逻辑就是用前面收集好的 exportsInfo 对象未模块的导出值分别生成导出语句\\n')])])]),a(\"h2\",{attrs:{id:\"总结\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#总结\"}},[e._v(\"#\")]),e._v(\" 总结\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"综上所述，Webpack 中 Tree Shaking 的实现分为如下步骤：\\n\\n在 FlagDependencyExportsPlugin 插件中根据模块的 dependencies 列表收集模块导出值，并记录到 ModuleGraph 体系的 exportsInfo 中\\n在 FlagDependencyUsagePlugin 插件中收集模块的导出值的使用情况，并记录到 exportInfo._usedInRuntime 集合中\\n在 HarmonyExportXXXDependency.Template.apply 方法中根据导出值的使用情况生成不同的导出语句\\n使用 DCE 工具删除 Dead Code，实现完整的树摇效果\\n\")])])])])}),[],!1,null,null,null);n.default=r.exports}}]);","extractedComments":[]}