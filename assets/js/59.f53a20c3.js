(window.webpackJsonp=window.webpackJsonp||[]).push([[59],{598:function(n,e,r){"use strict";r.r(e);var t=r(12),a=Object(t.a)({},(function(){var n=this,e=n.$createElement,r=n._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[r("h2",{attrs:{id:"基础语法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#基础语法"}},[n._v("#")]),n._v(" 基础语法")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v('let isDone: boolean = false;\nlet decLiteral: number = 6;\nlet name: string = "bob";\nlet list: number[] = [1, 2, 3];\nlet list: Array<number> = [1, 2, 3]; // 泛型\n\n// Declare a tuple type\nlet x: [string, number];\n// Initialize it\nx = [\'hello\', 10]; // OK\n当访问一个越界的元素，会使用联合类型替代\nx[3] = \'world\'; // OK, 字符串可以赋值给(string | number)类型\nconsole.log(x[5].toString()); // OK, \'string\' 和 \'number\' 都有 toString\n\n\nenum Color {Red, Green, Blue}\nlet c: Color = Color.Green;\n默认情况下，从0开始为元素编号。\n\n我们将上面的例子改成从 1开始编号：\nenum Color {Red = 1, Green, Blue}\nlet c: Color = Color.Green;\n\nlet notSure: any = 4;\n\n\nVoid\n某种程度上来说，void类型像是与any类型相反，它表示没有任何类型。\n当一个函数没有返回值时，你通常会见到其返回值类型是 void：\n\nfunction warnUser(): void {\n    console.log("This is my warning message");\n}\n\n\nlet u: undefined = undefined;\nlet n: null = null;\n默认情况下null和undefined是所有类型的子类型。\n就是说你可以把 null和undefined赋值给number类型的变量。⭐️\n\nObject\n\ndeclare function create(o: object | null): void;\n\ncreate({ prop: 0 }); // OK\ncreate(null); // OK\n\ncreate(42); // Error\ncreate("string"); // Error\ncreate(false); // Error\ncreate(undefined); // Error\n\n\n类型断言\n\n类型断言有两种形式。 其一是“尖括号”语法：\n\nlet someValue: any = "this is a string";\nlet strLength: number = (<string>someValue).length;\n\n另一个为as语法：\nlet someValue: any = "this is a string";\nlet strLength: number = (someValue as string).length;\n\n\ntype C = { a: string, b?: number }\nfunction f({ a, b }: C): void {\n    // ...\n}\n\n\n对象展开还有其它一些意想不到的限制。 首先，它仅包含对象 自身的可枚举属性。\n大体上是说当你展开一个对象实例时，你会丢失其方法：\n\nclass C {\n  p = 12;\n  m() {\n  }\n}\nlet c = new C();\nlet clone = { ...c };\nclone.p; // ok\nclone.m(); // error!  ⭐️\n\n\n\n\n')])])]),r("h2",{attrs:{id:"接口"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#接口"}},[n._v("#")]),n._v(" 接口")]),n._v(" "),r("p",[n._v("TypeScript的核心原则之一是对值所具有的结构进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在TypeScript里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("可选属性:\ninterface SquareConfig {\n  color?: string;\n  width?: number;\n}\n\n只读属性:\ninterface Point {\n    readonly x: number;\n    readonly y: number;\n}\n\nTypeScript具有ReadonlyArray<T>类型，它与Array<T>相似，只是把所有可变方法去掉了，\n因此可以确保数组创建后再也不能被修改：\n\nlet a: number[] = [1, 2, 3, 4];\nlet ro: ReadonlyArray<number> = a;\nro[0] = 12; // error!\nro.push(5); // error!\nro.length = 100; // error!\na = ro; // error!\n\n上面代码的最后一行，可以看到就算把整个ReadonlyArray赋值到一个普通数组也是不可以的。\n但是你可以用类型断言重写：\n\na = ro as number[]; // 绕开检查,可以通过类型断言  ⭐️⭐️⭐️⭐️⭐️\n\n做为变量使用的话用 const，若做为属性则使用readonly。\n\n\n\ninterface SquareConfig {\n    color?: string;\n    width?: number;\n    [propName: string]: any;\n}\n\n\n定义函数类型\ninterface SearchFunc {\n  (source: string, subString: string): boolean;\n}\n\nlet mySearch: SearchFunc;\nmySearch = function(source: string, subString: string) {\n  let result = source.search(subString);\n  return result > -1;\n}\n\n对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配。 比如，我们使用下面的代码重写上面的例子：\n\nlet mySearch: SearchFunc;\nmySearch = function(src: string, sub: string): boolean {\n  let result = src.search(sub);\n  return result > -1;\n}\n\n\n\ninterface Shape {\n    color: string;\n}\n\ninterface PenStroke {\n    penWidth: number;\n}\n\ninterface Square extends Shape, PenStroke {\n    sideLength: number;\n}\n\nlet square = <Square>{};\n\n\n可索引类型\n\n\n\n")])])]),r("h2",{attrs:{id:"类"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#类"}},[n._v("#")]),n._v(" 类")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("\n\n构造函数也可以被标记成 protected。\n这意味着这个类不能在包含它的类外被实例化，但是能被继承。\n\n\nprotected修饰符与 private修饰符的行为很相似，\n但有一点不同， protected成员在派生类中仍然可以访问。\n\n\n\nreadonly修饰符\n你可以使用 readonly关键字将属性设置为只读的。\n只读属性必须在声明时或构造函数里被初始化。 ⭐️⭐️⭐️⭐️⭐️\n\nclass Octopus {\n    readonly name: string;\n    readonly numberOfLegs: number = 8;\n    constructor (theName: string) {\n        this.name = theName;\n    }\n}\n\n\n\n\n\n\n")])])]),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("\n我们需要一种方法使返回值的类型与传入参数的类型是相同的。\n这里，我们使用了类型变量，它是一种特殊的变量，只用于表示类型而不是值。\n\nfunction identity<T>(arg: T): T {\n    return arg;\n}\n我们给identity添加了类型变量T。 T帮助我们捕获用户传入的类型（比如：number），\n之后我们就可以使用这个类型。 之后我们再次使用了T当做返回值类型。\n现在我们可以知道参数类型与返回值类型是相同的了。\n 这允许我们跟踪函数里使用的类型的信息。\n\n\n我们定义了泛型函数后，可以用两种方法使用。 第一种是，传入所有的参数，包含类型参数：\nlet output = identity<string>(\"myString\");\n // type of output will be 'string'\n这里我们明确的指定了T是string类型，并做为一个参数传给函数，使用了<>括起来而不是()。\n第二种方法更普遍。利用了类型推论 -- 即编译器会根据传入的参数自动地帮助我们确定T的类型：\nlet output = identity(\"myString\");  // type of output will be 'string'\n\n注意我们没必要使用尖括号（<>）来明确地传入类型；编译器可以查看myString的值，\n然后把T设置为它的类型。 类型推论帮助我们保持代码精简和高可读性。\n如果编译器不能够自动地推断出类型的话，只能像上面那样明确的传入T的类型，\n在一些复杂的情况下，这是可能出现的。\n\n\n\n泛型函数的类型与非泛型函数的类型没什么不同，只是有一个类型参数在最前面，像函数声明一样：\nfunction identity<T>(arg: T): T {\n    return arg;\n}\n\nlet myIdentity: <T>(arg: T) => T = identity;\n我们也可以使用不同的泛型参数名，只要在数量上和使用方式上能对应上就可以。\nfunction identity<T>(arg: T): T {\n    return arg;\n}\n\nlet myIdentity: <U>(arg: U) => U = identity;\n我们还可以使用带有调用签名的对象字面量来定义泛型函数：\nfunction identity<T>(arg: T): T {\n    return arg;\n}\n\nlet myIdentity: {<T>(arg: T): T} = identity;\n\n这引导我们去写第一个泛型接口了。 我们把上面例子里的对象字面量拿出来做为一个接口：\ninterface GenericIdentityFn {\n    <T>(arg: T): T;\n}\n\nfunction identity<T>(arg: T): T {\n    return arg;\n}\n\nlet myIdentity: GenericIdentityFn = identity;\n\n\n\n\nfunction loggingIdentity<T>(arg: T): T {\n    console.log(arg.length);  // Error: T doesn't have .length\n    return arg;\n}\n相比于操作any所有类型，我们想要限制函数去处理任意带有.length属性的所有类型。 只要传入的类型有这个属性，我们就允许，就是说至少包含这一属性。 为此，我们需要列出对于T的约束要求。\n为此我们定义一个接口来描述约束条件。 创建一个包含.length属性的接口，使用这个接口和extends关键字来实现约束：\n\ninterface Lengthwise {\n    length: number;\n}\n\nfunction loggingIdentity<T extends Lengthwise>(arg: T): T {\n    console.log(arg.length);  // Now we know it has a .length property, so no more error\n    return arg;\n}\n\n\n在泛型约束中使用类型参数\n你可以声明一个类型参数，且它被另一个类型参数所约束。\n比如，现在我们想要用属性名从对象里获取这个属性。\n并且我们想要确保这个属性存在于对象obj上，因此我们需要在这两个类型之间使用约束。\n\nfunction getProperty<T, K extends keyof T>(obj: T, key: K) {\n    return obj[key];\n}\n\nlet x = { a: 1, b: 2, c: 3, d: 4 };\n\ngetProperty(x, \"a\"); // okay\ngetProperty(x, \"m\"); // error: Argument of type 'm' isn't assignable to 'a' | 'b' | 'c' |\n\n\n\n\n在TypeScript使用泛型创建工厂函数时，需要引用构造函数的类类型。比如，\nfunction create<T>(c: {new(): T; }): T {\n    return new c();\n}\n\n\n\n")])])]),r("h2",{attrs:{id:"decorators"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#decorators"}},[n._v("#")]),n._v(" Decorators")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v('\n装饰器求值\n类中不同声明上的装饰器将按以下规定的顺序应用：\n参数装饰器，然后依次是方法装饰器，访问符装饰器，或属性装饰器应用到每个实例成员。\n参数装饰器，然后依次是方法装饰器，访问符装饰器，或属性装饰器应用到每个静态成员。\n参数装饰器应用到构造函数。\n类装饰器应用到类。\n\n\n1 类装饰器\n应用于类构造函数，其参数是类的构造函数。\n注意class并不是像Java那种强类型语言中的类，而是JavaScript构造函数的语法糖。\n\nfunction Path(path: string) {\n    return function (target: Function) {\n        !target.prototype.$Meta && (target.prototype.$Meta = {})\n        target.prototype.$Meta.baseUrl = path;\n    };\n}\n\n@Path(\'/hello\')\nclass HelloService {\n    constructor() {}\n}\n\nconsole.log(HelloService.prototype.$Meta);// 输出：{ baseUrl: \'/hello\' }\nlet hello = new HelloService();\nconsole.log(hello.$Meta) // 输出：{ baseUrl: \'/hello\' }\n\n\n\n\n2 方法装饰器\n它会被应用到方法的 属性描述符上，可以用来监视，修改或者替换方法定义。\n方法装饰会在运行时传入下列3个参数：\n\n1、对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。\n2、成员的名字。\n3、成员的属性描述符。\nfunction GET(url: string) {\n    return function (target, methodName: string, descriptor: PropertyDescriptor) {\n        !target.$Meta && (target.$Meta = {});\n        target.$Meta[methodName] = url;\n    }\n}\n\nclass HelloService {\n    constructor() { }\n    @GET("xx")\n    getUser() { }\n}\n\nconsole.log((<any>HelloService).$Meta);\n\n\n\n3 方法参数装饰器\n参数装饰器表达式会在运行时当作函数被调用，传入下列3个参数：\n\n1、对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。\n2、参数的名字。\n3、参数在函数参数列表中的索引。\nfunction PathParam(paramName: string) {\n    return function (target, methodName: string, paramIndex: number) {\n        !target.$Meta && (target.$Meta = {});\n        target.$Meta[paramIndex] = paramName;\n    }\n}\n\nclass HelloService {\n    constructor() { }\n    getUser( @PathParam("userId") userId: string) { }\n}\n\nconsole.log((<any>HelloService).prototype.$Meta); // {\'0\':\'userId\'}\n\n\n\n4 属性装饰器\n属性装饰器表达式会在运行时当作函数被调用，传入下列2个参数：\n\n1、对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。\n2、成员的名字。\nfunction DefaultValue(value: string) {\n    return function (target: any, propertyName: string) {\n        target[propertyName] = value;\n    }\n}\n\nclass Hello {\n    @DefaultValue("world") greeting: string;\n}\n\nconsole.log(new Hello().greeting);// 输出: world\n\n\n⭐️⭐️⭐️⭐️⭐️\n\n装饰器加载顺序\nfunction ClassDecorator() {\n    return function (target) {\n        console.log("I am class decorator");\n    }\n}\nfunction MethodDecorator() {\n    return function (target, methodName: string, descriptor: PropertyDescriptor) {\n        console.log("I am method decorator");\n    }\n}\nfunction Param1Decorator() {\n    return function (target, methodName: string, paramIndex: number) {\n        console.log("I am parameter1 decorator");\n    }\n}\nfunction Param2Decorator() {\n    return function (target, methodName: string, paramIndex: number) {\n        console.log("I am parameter2 decorator");\n    }\n}\nfunction PropertyDecorator() {\n    return function (target, propertyName: string) {\n        console.log("I am property decorator");\n    }\n}\n\n@ClassDecorator()\nclass Hello {\n    @PropertyDecorator()\n    greeting: string;\n\n\n    @MethodDecorator()\n    greet( @Param1Decorator() p1: string, @Param2Decorator() p2: string) { }\n}\n输出结果：\n\nI am property decorator\nI am parameter2 decorator\nI am parameter1 decorator\nI am method decorator\nI am class decorator\n从上述例子得出如下结论：\n\n1、有多个参数装饰器时：从最后一个参数依次向前执行\n\n2、方法和方法参数中参数装饰器先执行。\n\n3、类装饰器总是最后执行。\n\n4、方法和属性装饰器，谁在前面谁先执行。因为参数属于方法一部分，所以参数会一直紧紧挨着方法执行。上述例子中属性和方法调换位置，输出如下结果：\n\nI am parameter2 decorator\nI am parameter1 decorator\nI am method decorator\nI am property decorator\nI am class decorator\n\n')])])]),r("p",[n._v("record")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("\n\ntype Car = 'Audi' | 'BMW' | 'MercedesBenz'\n\nconst cars = {\n    Audi: { age: 119 },\n    BMW: { age: 113 },\n    MercedesBenz: { age: 133 },\n}\n复制代码虽然这个写法没问题，但是有没有考虑过类型安全的问题？\n比如：\n\n我们忘记写了一个汽车品牌，他会报错吗？\n我们拼写属性名错误了，它会报错吗？\n我们添加了一个非上述三个品牌的品牌进去，他会报错吗？\n我们更改了其中一个品牌的名字，他会有报错提醒吗？\n\n上述这种写法统统不会，这就需要Record的帮助。\ntype Car = 'Audi' | 'BMW' | 'MercedesBenz'\ntype CarList = Record<Car, {age: number}>\n\nconst cars: CarList = {\n    Audi: { age: 119 },\n    BMW: { age: 113 },\n    MercedesBenz: { age: 133 },\n}\n\n\n")])])])])}),[],!1,null,null,null);e.default=a.exports}}]);