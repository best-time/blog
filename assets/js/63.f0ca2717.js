(window.webpackJsonp=window.webpackJsonp||[]).push([[63],{603:function(n,e,t){"use strict";t.r(e);var s=t(12),a=Object(s.a)({},(function(){var n=this.$createElement,e=this._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[e("h1",{attrs:{id:"vue"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue"}},[this._v("#")]),this._v(" vue")]),this._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v('<span v-once>这个将不会改变: {{ msg }}</span>\n\n\nv-bind 缩写\n\x3c!-- 完整语法 --\x3e\n<a v-bind:href="url">...</a>\n\n\x3c!-- 缩写 --\x3e\n<a :href="url">...</a>\n\nv-on 缩写\n\x3c!-- 完整语法 --\x3e\n<a v-on:click="doSomething">...</a>\n\n\x3c!-- 缩写 --\x3e\n<a @click="doSomething">...</a>\n\ncomputed 有缓存\n对于任何复杂逻辑，你都应当使用计算属性\n我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。\n然而，不同的是计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。\n这就意味着只要 message 还没有发生改变，多次访问 reversedMessage 计算属性会立即返回之前的计算结果，\n而不必再次执行函数。\n\nwatch\n然而，通常更好的做法是使用计算属性而不是命令式的 watch 回调\n计算属性默认只有 getter ，不过在需要时你也可以提供一个 setter\n\n虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。\n这就是为什么 Vue 通过 watch 选项提供了一个更通用的方法，来响应数据的变化。\n当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的\n\n<div v-bind:class="{ active: isActive }"></div>\n\n注意，v-show 不支持 <template> 元素，也不支持 v-else。\n\n当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级。\n\n在 v-for 块中，我们可以访问所有父作用域的属性。\n\n在遍历对象时，会按 Object.keys() 的结果遍历，但是不能保证它的结果在不同的 JavaScript 引擎下都一致。\n\n不要使用对象或数组之类的非基本类型值作为 v-for 的 key。请用字符串或数值类型的值。\n\n解决非相应\n以下两种方式都可以实现和 vm.items[indexOfItem] = newValue 相同的效果，同时也将在响应式系统内触发状态更新：\n\n// Vue.set\nVue.set(vm.items, indexOfItem, newValue)\n// Array.prototype.splice\nvm.items.splice(indexOfItem, 1, newValue)\n\n2.2.0+ 的版本里，当在组件上使用 v-for 时，key 现在是必须的\n\nVue.js 为 v-on 提供了事件修饰符。之前提过，修饰符是由点开头的指令后缀来表示的。\n\n.stop\n.prevent\n.capture\n.self\n.once\n.passive\n\n\nkeyCode 的事件用法已经被废弃了并可能不会被最新的浏览器支持\n\n\n为了在必要的情况下支持旧浏览器，Vue 提供了绝大多数常用的按键码的别名：\n\n.enter\n.tab\n.delete (捕获“删除”和“退格”键)\n.esc\n.space\n.up\n.down\n.left\n.right\n\n\nv-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件：\n\ntext 和 textarea 元素使用 value 属性和 input 事件；\ncheckbox 和 radio 使用 checked 属性和 change 事件；\nselect 字段将 value 作为 prop 并将 change 作为事件。\n\n\n因为组件是可复用的 Vue 实例，所以它们与 new Vue 接收相同的选项，\n例如 data、computed、watch、methods 以及生命周期钩子等。仅有的例外是像 el 这样根实例特有的选项\n\nnew Vue({\n  el: \'#blog-post-demo\',\n  data: {\n    posts: [\n      { id: 1, title: \'My journey with Vue\' },\n      { id: 2, title: \'Blogging with Vue\' },\n      { id: 3, title: \'Why Vue is so fun\' }\n    ]\n  }\n})\n\n<blog-post\n  v-for="post in posts"\n  v-bind:key="post.id"\n  v-bind:title="post.title"\n></blog-post>\n如上所示，你会发现我们可以使用 v-bind 来动态传递 prop。\n\n\n自定义事件也可以用于创建支持 v-model 的自定义输入组件。记住：\n\n<input v-model="searchText">\n等价于：\n\n<input\n  v-bind:value="searchText"\n  v-on:input="searchText = $event.target.value"\n>\n\n---------------------------------------------------------------\n当用在组件上时，v-model 则会这样：\n\n<custom-input\n  v-bind:value="searchText"\n  v-on:input="searchText = $event"\n></custom-input>\n为了让它正常工作，这个组件内的 <input> 必须：\n\n将其 value 特性绑定到一个名叫 value 的 prop 上\n在其 input 事件被触发时，将新的值通过自定义的 input 事件抛出\n写成代码之后是这样的：\n\nVue.component(\'custom-input\', {\n  props: [\'value\'],\n  template: `\n    <input\n      v-bind:value="value"\n      v-on:input="$emit(\'input\', $event.target.value)"\n    >\n  `\n})\n\n---------------------------------------------------------------\n\ntab切换实现\n上述内容可以通过 Vue 的 <component> 元素加一个特殊的 is 特性来实现：\n\n\x3c!-- 组件会在 `currentTabComponent` 改变时改变 --\x3e\n<component v-bind:is="currentTabComponent"></component>\n在上述示例中，currentTabComponent 可以包括\n\n已注册组件的名字，或\n一个组件的选项对象\n\n将 v-bind.sync 用在一个字面量的对象上，\n例如 v-bind.sync=”{ title: doc.title }”，是无法正常工作的，因为在解析一个像这样的复杂表达式的时候，\n有很多边缘情况需要考虑。\n\n父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。\n\n\n\n选项合并\n当组件和混入对象含有同名选项时，这些选项将以恰当的方式进行“合并”。\n\n比如，数据对象在内部会进行递归合并，并在发生冲突时以组件数据优先。\n同名钩子函数将合并为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子之前调用\n\n值为对象的选项，例如 methods、components 和 directives，将被合并为同一个对象。\n两个对象键名冲突时，取组件对象的键值对。\n注意：Vue.extend() 也使用同样的策略进行合并。\n\n\nvuex 是一个专门为vue.js应用程序开发的状态管理模式。\n这个状态我们可以理解为在data中的属性，需要共享给其他组件使用的部分。\n\n也就是说，是我们需要共享的data，使用vuex进行统一集中式的管理\n\nvuex中，有默认的五种基本的对象：\n\nstate：存储状态（变量）\ngetters：对数据获取之前的再次编译，可以理解为state的计算属性。我们在组件中使用 $sotre.getters.fun()\nmutations：修改状态，并且是同步的。在组件中使用$store.commit(\'\',params)。这个和我们组件中的自定义事件类似。\nactions：异步操作。在组件中使用是$store.dispath(\'\')\nmodules：store的子模块，为了开发大型项目，方便状态管理而使用的。这里我们就不解释了，用起来和上面的一样。\n\n\n')])])])])}),[],!1,null,null,null);e.default=a.exports}}]);