(window.webpackJsonp=window.webpackJsonp||[]).push([[48],{590:function(n,e,a){"use strict";a.r(e);var t=a(12),s=Object(t.a)({},(function(){var n=this,e=n.$createElement,a=n._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("h2",{attrs:{id:"了解改动的背景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#了解改动的背景"}},[n._v("#")]),n._v(" 了解改动的背景")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("CodeReview不是一上来就看代码，这样有可能你会看的云里雾里，纯粹是浪费时间。CodeReview虽然是Review代码，\n但是首先你的知道你要看的代码实现了什么样的功能，是在什么样的背景下去做的，清楚前因后果之后，你才能知道这个代码大概应该怎么去写，\n你才能更好的去Review别人的代码、去发现别人的问题。\n\n")])])]),a("h2",{attrs:{id:"纵观全局"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#纵观全局"}},[n._v("#")]),n._v(" 纵观全局")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("知道背景之后，在你脑海中就会有一个大概的编码思路，也有个流程主线。这个时候可能有两种情况，你和写代码人的思路相同，\n那你就顺着你们共同的思路去帮忙Review整个流程是否正确。另一种情况就是你们思路不同，你就得看代码去了解写作者的思路，\n然后确认是谁的思路有问题，或者是谁的思路更好，然后同写作者一起将这个流程优化到更优。\n")])])]),a("h2",{attrs:{id:"逐层细化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#逐层细化"}},[n._v("#")]),n._v(" 逐层细化")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("确定完整个流程之后，就可以逐步深入到代码细节中了，细节可以Review的地方就很多了，可以看下下一节的内容，这里就先不展开了。\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("总结出以下几点：\n\n「功能性：」 代码所实现的功能是否和预期一样，是否实现了所有必须的功能？\n「复杂性：」 功能实现是否过于复杂？过于复杂的代码更容易出问题，而且可维护性也会更低。\n「代码风格：」 代码是否符合团队编码规范？\n「文档&注释：」 如果代码功能有改动，关注下相关文档和注释有没有同步改动。错误的注释和文档可能会让未来的开发者产生理解成本。\n「代码亮点：」 如果你看到变更中做得好的地方，也别吝啬你的赞美。\n\n上面描述更偏概括性，我们来举一些更详细的例子，帮助大家理解上面几点。\n\n代码设计良好，可读性和可维护性高。\n是否有线程安全的bug。\n代码没有增加不必要的复杂性。\n开发者没有写一些目前没有在用的代码，这种无用的代码未来大概率也不会用，所以不要假设。\n代码有适当的单元测试。\n测试逻辑设计良好。\n开发者使用了清晰明了的变量和函数命名。\n注释清晰明了且实用，并且解释清楚了为什么这么做，而不仅仅是做了啥。\n代码有相应完善的文档。\n代码风格符合规范。\n代码有没有更优的实现？（性能、资源占用……）\n")])])]),a("h2",{attrs:{id:"提交前先做好自审"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#提交前先做好自审"}},[n._v("#")]),n._v(" 提交前先做好自审")]),n._v(" "),a("h2",{attrs:{id:"写清楚变更描述"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#写清楚变更描述"}},[n._v("#")]),n._v(" 写清楚变更描述")]),n._v(" "),a("h2",{attrs:{id:"单个变更尽可能短"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单个变更尽可能短"}},[n._v("#")]),n._v(" 单个变更尽可能短")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("一个非常大的变更几乎没有Review，因为大的改动首先就很难Review，其实也更耗费时间，还有出问题的概率也更大，谁Review通过了代码但之后上线出问题，\n可能是要和你一起背锅的。所以建议大家将大的代码变更尽可能拆小，因为小的变更有以下这些好处:\n\n「代码评审更快」 与比起花30分钟评审一个大的变更相比，对Review代码的人来说花5分钟审查一系列小的变更更加容易.\nReview「更加彻底。」 进行较大的更改后，审阅者和作者往往会因大量详细评论的来回移动而感到沮丧，有时这些评论会漏掉或遗漏重要的观点。\n「减少导致bug的可能性。」 由于您所做的更改较少，因此您和您的审阅者更容易有效地推断出CL的影响，并查看是否导致bug。\n「减少不必要的工作」 当你写了一个巨大的变更，然后评审者觉得你总体方向错了，这会导致你浪费大量的工作。\n「更方便合并代码」 因为大型的变更会导致大量的冲突，因此合代码的时候会耗费很多时间，而且可能因合并代码导致问题，我们就出现过好几次代码合并的时候冲掉别人代码的情况。\n「有助于你作出更好的设计」 优雅的设计并且完善一个小的改动比大的改动更加容易\n「降低评审者的难度」 提审部分改动，不会影响你继续编码。\n「如果真出问题，回滚更容易」 这个就不用多解释了吧。\n对于那些很难拆分的变更，也不是需要完全禁止，有时候就是有改动非常大，而且无法再去拆分了，这时候还是建议通过其他方式来保证代码质量，比如全流程测试。然后也建议做好出问题时的快速恢复方案。\n")])])]),a("h2",{attrs:{id:"general"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#general"}},[n._v("#")]),n._v(" General")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("\n代码是否能运行？\n项目状态是否描述？project status\n代码是否容易理解？\n代码是否根据编码标准/指南编写的？\n代码是否与新技术同步？\n部分代码是否重复多次？\n代码是否容易调试？\n函数|类|组件是否太长，函数或类是否有太多责任？\n组件销毁是否删除了监听器？\n文件名|变量是否符合团队整体规范？\n是否从npm删除未使用的安装包？\n代码应该遵循定义的体系结构。如代码分离，Web component。\n")])])]),a("h2",{attrs:{id:"codestyle"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#codestyle"}},[n._v("#")]),n._v(" CodeStyle")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("\n无写死数据(hardcoded)，使用常量(const)。❎if(code === 10){} ✅const status=10; if(code === status){}。\n避免过多if else。\n删除注释代码。\n删除不必要的注释。\n添加必要注释。必要注释说明代码功能和原因。\n\nES6|7 ...\n\n使用ES6。\n使用箭头函数。避免let that|self = this。\n使用默认值。\n使用...\n使用 const let。\n使用import export。\n使用``字符串模板。\n使用arrays | objects 解构赋值。\n使用Promise  | Asyns/Await。\n\nThird-Party Libraries\n\n使用lodash等functions，而不是自我实现。\n尽量使用项目已引用UI库，而不是重新写组件。\n\nESLint\n\n无任何lint警告和错误。\n无 console.log()。特殊场景特殊对待，比如知乎控制台招聘信息等。\n\nCSS  |  CSS in JS\n\n命名规范。符合团队命名规则。\n是否使用了JS中的CSS库?\n除非使用rgba()，否则使用十六进制颜色代码#000。\n使用flexbox。\n避免使用!importantjuejin.im/post/5d5504…\n避免给 width, height, top, left等添加animate，使用transform。原因可以参考大漠的https://github.com/amfe/article/issues/47\n项目统一使用相同单位。\n避免使用内联样式。将内容与设计分开，维护更加简单。\n\n\n")])])]),a("h2",{attrs:{id:"代码-review-应该提供些什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#代码-review-应该提供些什么"}},[n._v("#")]),n._v(" 代码 Review 应该提供些什么？")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("\nJonathan Betz 前 Google 开发者，曾说过： code review 理想中应该六件事情 ：\n\n正确性 代码是否像声明的那样正确完成了功能？\n复杂性 是否很直接的完成了目标？\n连续性 代码是否始终如一的完成目标？\n维护性 代码是否能被其它人员不用费太多努力就可以完成扩展？\n扩展性 代码在用户数100的情况下工作，那么在10000人的情况下是否能正确工作？ 是否有优化的可能？\n风格 代码是否遵守了一个特别的风格规范\n我同意以上的列表内容，同时认为reviewer应该尤其注意以下一些事项，扩展之后可以成为codeReview的指导实践：\n\n提供清晰的评论，讲述知识，良好沟通。\n指出代码实现上的不足之处（避免过分批评）\n陈述为什么某一方法不被推荐，如果可能，提供博文，文档，规范， MDN页面， jsPerf测试结果以支持陈述\n提出替换方案，以独立的可运行的形式或者通过fork的方式集成。这样开发者就能清晰的看到他们哪里做的不好\n优先聚焦于解决方案，然后才是编码风格。编码风格上的建议可以在review之外给出，在此之前尽量忙于解决基本问题。\nReview请求之外的部分。当然这完成由reviewer自己决定。 我经常会在要求的部分之外给出自己的建议，到目前为止还没有听到抱怨，所在我假定这不是一件坏事。\n\n\n\n\n\n比如Code Review阶段会检查这些东西:\n\n编程原则、设计思想. 例如符合SOLID原则? 是否足够DRY？接口设计是否简洁易扩展、\n模块耦合程度、代码重复\n代码健壮性。是否存在内存泄露、是否线程安全、是否有潜在性能问题和异常、错误是否被处理\n代码的性能和效率。\n是否有没有考虑到的场景？\n\n如果你们是第一次推行Code Review, 可以建立一个检查列表，对照着进行检查。熟练后，心中自然无码。\n\n\n\n\nArchitecture/Design\n单一职责原则.\n\n这是经常被违背的原则。一个类只能干一个事情, 一个方法最好也只干一件事情。 比较常见的违背是一个类既干UI的事情，又干逻辑的事情, 这个在低质量的代码里很常见。\n\n行为是否统一\n\n比如缓存是否统一，错误处理是否统一， 错误提示是否统一， 弹出框是否统一 等等。\n\n同一逻辑/同一行为 有没有走同一Code Path？低质量程序的另一个特征是，同一行为/同一逻辑，因为出现在不同的地方或者被不同的方式触发，没有走同一Code Path 或者各处有一份copy的实现， 导致非常难以维护。\n\n代码污染\n\n代码有没有对其他模块强耦合 ？\n\n重复代码\n\n主要看有没有把公用组件，可复用的代码，函数抽取出来。\n\nOpen/Closed 原则\n\n就是好不好扩展。 Open for extension, closed for modification.\n\n面向接口编程 和 不是 面向实现编程\n\n主要就是看有没有进行合适的抽象， 把一些行为抽象为接口。\n\n健壮性\n\n对Corner case有没有考虑完整，逻辑是否健壮？有没有潜在的bug？\n\n有没有内存泄漏？有没有循环依赖?（针对特定语言，比如Objective-C) ？有没有野指针？\n\n有没有考虑线程安全性， 数据访问的一致性\n\n错误处理\n\n有没有很好的Error Handling？比如网络出错，IO出错。\n\n改动是不是对代码的提升\n\n新的改动是打补丁，让代码质量继续恶化，还是对代码质量做了修复？\n\n效率/性能\n\n客户端程序 对频繁消息 和较大数据等耗时操作是否处理得当。\n\n关键算法的时间复杂度多少？有没有可能有潜在的性能瓶颈。\n\n其中有一部分问题，比如一些设计原则， 可预见的效率问题， 开发模式一致性的问题 应该尽早在Design Review阶段解决。如果Design阶段没有解决，那至少在Code Review阶段也要把它找出来。\n\nStyle\n可读性\n\n衡量可读性的可以有很好实践的标准，就是Reviewer能否非常容易的理解这个代码。 如果不是，那意味着代码的可读性要进行改进。\n\n命名\n\n命名对可读性非常重要，我倾向于函数名/方法名长一点都没关系，必须是能自我阐述的。\n\n英语用词尽量准确一点（哪怕有时候需要借助Google Translate，是值得的）\n\n函数长度/类长度\n\n函数太长的不好阅读。 类太长了，比如超过了1000行，那你要看一下是否违反的“单一职责” 原则。\n\n注释\n\n恰到好处的注释。 但更多我看到比较差质量的工程的一个特点是缺少注释。\n\n参数个数\n\n不要太多， 一般不要超过3个。\n\n")])])]),a("h2",{attrs:{id:"最佳实践"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#最佳实践"}},[n._v("#")]),n._v(" 最佳实践")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('\n可维护的代码有一些特征。一般来说，如果说代码是可维护的，它需要遵循以下特点。 \n 可理解性——其他人可以接手代码并理解它的意图和一般途径，而无需原开发人员的完整解释。 \n 直观性——代码中的东西一看就能明白，不管其操作过程多么复杂。\n 可适应性——代码以一种数据上的变化不要求完全重写的方法撰写。\n 可扩展性——在代码架构上已考虑到在未来允许对核心功能进行扩展。\n 可调试性——当有地方出错时，代码可以给予你足够的信息来尽可能直接地确定问题所在。\n\n\n一般而言，有如下一些地方需要进行注释。\n 函数和方法——每个函数或方法都应该包含一个注释，描述其目的和用于完成任务所可能使用 的算法。\n\t陈述事先的假设也非常重要，如参数代表什么，函数是否有返回值(因为这不能从函 数定义中推断出来)。\n 大段代码——用于完成单个任务的多行代码应该在前面放一个描述任务的注释。\n 复杂的算法——如果使用了一种独特的方式解决某个问题，则要在注释中解释你是如何做的。\n   这不仅仅可以帮助其他浏览你代码的人，也能在下次你自己查阅代码的时候帮助理解。\n Hack——因为存在浏览器差异，JavaScript 代码一般会包含一些 hack。\n\t不要假设其他人在看代码的时候能够理解 hack 所要应付的浏览器问题。\n\t如果因为某种浏览器无法使用普通的方法，所以你需要用一些不同的方法，那么请将这些信息放在注释中。\n\t这样可以减少出现这种情况的可能性:有人偶然看到你的 hack，然后“修正”了它，最后重新引入了你本来修正了的错误。\n\t缩进和注释可以带来更可读的代码，在未来则更容易维护。\n\n\n命名的一般规则如下所示\n 变量名应为名词如 car 或 person。\n 函数名应该以动词开始，如 getName()。返回布尔类型值的函数一般以 is 开头，如isEnable()。\n 变量和函数都应使用合乎逻辑的名字，不要担心长度。长度问题可以通过后处理和压缩来缓解。\n\n"o"代表对象，"s"代表字符串，"i" 代表整数，"f"代表浮点数，"b"代表布尔型。\n如下所示:\n//用于指定数据类型的匈牙利标记法 \nvar bFound; //布尔型 \nvar iCount; //整数\nvar sName; //字符串 \nvar oPerson; //对象\n\n\n\n')])])])])}),[],!1,null,null,null);e.default=s.exports}}]);